const { Client, LocalAuth, MessageMedia, Buttons, List } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs');
const autoAcceptRequests = {};

let text = '';
let gameStates = {};

// ---------------------- DATABASE ----------------------
let groupData = {};
let games = {};
let economy = {};
let userStats = {};
let marriages = {};
let pets = {};
let warnings = {};
let automodConfig = {};
let botData = {};
const startTime = Date.now();

function loadData() {
    try {
        if (fs.existsSync('./groupData.json')) groupData = JSON.parse(fs.readFileSync('./groupData.json', 'utf8'));
        if (fs.existsSync('./games.json')) games = JSON.parse(fs.readFileSync('./games.json', 'utf8'));
        if (fs.existsSync('./economy.json')) economy = JSON.parse(fs.readFileSync('./economy.json', 'utf8'));
        if (fs.existsSync('./userStats.json')) userStats = JSON.parse(fs.readFileSync('./userStats.json', 'utf8'));
        if (fs.existsSync('./marriages.json')) marriages = JSON.parse(fs.readFileSync('./marriages.json', 'utf8'));
        if (fs.existsSync('./pets.json')) pets = JSON.parse(fs.readFileSync('./pets.json', 'utf8'));
        if (fs.existsSync('./warnings.json')) warnings = JSON.parse(fs.readFileSync('./warnings.json', 'utf8'));
        if (fs.existsSync('./automod.json')) automodConfig = JSON.parse(fs.readFileSync('./automod.json', 'utf8'));
        if (fs.existsSync('./botData.json')) botData = JSON.parse(fs.readFileSync('./botData.json', 'utf8'));
        if (fs.existsSync('./gameStates.json')) gameStates = JSON.parse(fs.readFileSync('./gameStates.json', 'utf8'));
    } catch (err) {
        console.log('‚ö†Ô∏è Errore caricamento dati:', err);
    }
}

function saveData() {
    try {
        fs.writeFileSync('./groupData.json', JSON.stringify(groupData, null, 2));
        fs.writeFileSync('./games.json', JSON.stringify(games, null, 2));
        fs.writeFileSync('./economy.json', JSON.stringify(economy, null, 2));
        fs.writeFileSync('./userStats.json', JSON.stringify(userStats, null, 2));
        fs.writeFileSync('./marriages.json', JSON.stringify(marriages, null, 2));
        fs.writeFileSync('./pets.json', JSON.stringify(pets, null, 2));
        fs.writeFileSync('./warnings.json', JSON.stringify(warnings, null, 2));
        fs.writeFileSync('./automod.json', JSON.stringify(automodConfig, null, 2));
        fs.writeFileSync('./gameStates.json', JSON.stringify(gameStates, null, 2));
        fs.writeFileSync('./botData.json', JSON.stringify(botData, null, 2));
    } catch (err) {
        console.log('‚ö†Ô∏è Errore salvataggio dati:', err);
    }
}

function initGroup(groupId) {
    if (!groupData[groupId]) {
        groupData[groupId] = {
            mutedUsers: [],
            bannedUsers: [],
            warnings: {},
            adminMode: false,
            antilink: false,
            blockedWords: [],
            slowmode: 0,
            lastMessage: {},
            rules: '',
            welcomeEnabled: true,
            goodbyeEnabled: true,
            autoKickWarns: 3,
            welcomeMessage: 'üëã Benvenuto {user} nel gruppo *{group}*! üéâ',
            goodbyeMessage: 'üëã Ciao {user}, ci mancherai! üíî',
            levelSystem: true,
            antiSpam: false,
            polls: {},
            lockSettings: false,
            antiBot: false,
            maxWarns: 3,
            muteTime: {}
        };
    }
    if (!automodConfig[groupId]) {
        automodConfig[groupId] = {
            autoDelete: true,
            antiFlood: false,
            antiRaid: false,
            captchaEnabled: false,
            maxMessages: 5,
            timeWindow: 10
        };
    }
}

function initUser(userId) {
    if (!economy[userId]) {
        economy[userId] = {
            money: 100,
            bank: 0,
            inventory: [],
            lastDaily: 0,
            lastWork: 0,
            lastRob: 0,
            lastCrime: 0,
            lastWeekly: 0,
            lastMonthly: 0
        };
    }
    if (!userStats[userId]) {
        userStats[userId] = {
            level: 1,
            xp: 0,
            messages: 0,
            reputation: 0,
            bio: '',
            lastXP: 0,
            lastRep: 0
        };
    }
    if (!pets[userId]) {
        pets[userId] = {
            name: '',
            type: '',
            hunger: 100,
            happiness: 100,
            health: 100,
            lastFed: 0,
            lastPlayed: 0
        };
    }
}

// ---------------------- CLIENT ----------------------
const client = new Client({
    authStrategy: new LocalAuth(),
    puppeteer: {
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage', '--disable-gpu']
    }
});

client.on('qr', (qr) => {
    console.log('üì± Scansiona questo QR con WhatsApp:');
    qrcode.generate(qr, { small: true });
});

client.on('ready', () => {
    console.log('‚úÖ ü§ñ Bot WhatsApp pronto e operativo!');
    loadData();
});

client.on('authenticated', () => {
    console.log('üîê Autenticazione completata!');
});

client.on('auth_failure', () => {
    console.error('‚ùå Autenticazione fallita!');
});

client.on('disconnected', (reason) => {
    console.log('‚ö†Ô∏è Bot disconnesso:', reason);
});

// ---------------------- UTILITY ----------------------
const nowSeconds = () => Math.floor(Date.now() / 1000);
const getUserIdFromMsg = (msg) => msg.author || msg.from;

const getNormalizedNumber = async (msg) => {
    try {
        const contact = await msg.getContact();
        const userId = contact.id._serialized;
        return userId.split('@')[0];
    } catch {
        const userId = msg.author || msg.from;
        return userId.split('@')[0];
    }
};

// Controlla se l'autore del messaggio √® admin nel gruppo
async function isAdmin(msg, chat) {
  try {
    // Se non √® un gruppo, consideriamo "true" (comando in privato)
    if (!chat || !chat.isGroup) return true;

    // Proviamo prima a ottenere il contact (pi√π affidabile)
    let senderIdRaw = '';
    try {
      const contact = await msg.getContact(); // restituisce il contatto del mittente
      senderIdRaw = contact && contact.id && contact.id._serialized ? contact.id._serialized : '';
    } catch (e) {
      // fallback se getContact() fallisce
      senderIdRaw = msg.author || msg.from || '';
    }

    // Normalizza (prendi la parte prima di @)
    const normalize = id => (id || '').split('@')[0];

    const userId = normalize(senderIdRaw);

    // Prendi lo stato aggiornato della chat
    const freshChat = await client.getChatById(chat.id._serialized);
    if (!freshChat || !Array.isArray(freshChat.participants)) return false;

    const participant = freshChat.participants.find(p => {
      const pId = p && p.id && p.id._serialized ? p.id._serialized : '';
      return normalize(pId) === userId;
    });

    // Verifica flag admin/superadmin (some versions use isAdmin/isSuperAdmin)
    return Boolean(participant && (participant.isAdmin === true || participant.isSuperAdmin === true));
  } catch (err) {
    console.error('isAdmin error:', err);
    return false;
  }
}

// Controlla se il bot √® admin nel gruppo
async function isBotAdmin(chat) {
  try {
    if (!chat || !chat.isGroup) return false;

    // Ottieni l'ID del bot in modo pi√π affidabile
    let botId = '';
    
    // Prova diversi metodi per ottenere l'ID del bot
    if (client.info && client.info.wid) {
      botId = client.info.wid._serialized || client.info.wid.user || '';
    } else if (client.info && client.info.me) {
      botId = client.info.me._serialized || client.info.me.user || '';
    }
    
    // Se non otteniamo l'ID completo, proviamo ad estrarre solo il numero
    const botNumber = botId.split('@')[0];
    
    if (!botNumber) {
      console.log('‚ö†Ô∏è Impossibile ottenere ID bot');
      return false;
    }

    // Ottieni la chat aggiornata con i partecipanti
    const freshChat = await client.getChatById(chat.id._serialized);
    
    if (!freshChat || !Array.isArray(freshChat.participants)) {
      console.log('‚ö†Ô∏è Impossibile ottenere partecipanti del gruppo');
      return false;
    }

    // Cerca il bot tra i partecipanti
    const botParticipant = freshChat.participants.find(p => {
      if (!p || !p.id || !p.id._serialized) return false;
      const participantNumber = p.id._serialized.split('@')[0];
      return participantNumber === botNumber;
    });

    if (!botParticipant) {
      console.log('‚ö†Ô∏è Bot non trovato tra i partecipanti');
      return false;
    }

    // Verifica se il bot √® admin o super admin
    const isAdminStatus = botParticipant.isAdmin === true || botParticipant.isSuperAdmin === true;
    
    // Debug log (rimuovi in produzione)
    console.log(`Bot admin status in ${chat.name}: ${isAdminStatus}`);
    
    return isAdminStatus;

  } catch (err) {
    console.error('‚ùå isBotAdmin error:', err.message);
    return false;
  }
}


function addXP(userId, amount) {
    initUser(userId);
    const now = Date.now();
    if (now - userStats[userId].lastXP < 60000) return false;
    userStats[userId].xp += amount;
    userStats[userId].lastXP = now;
    const xpNeeded = userStats[userId].level * 100;
    if (userStats[userId].xp >= xpNeeded) {
        userStats[userId].level++;
        userStats[userId].xp = 0;
        saveData();
        return true;
    }
    saveData();
    return false;
}



// Funzioni helper per livelli
function calculateLevel(xp) {
    return Math.floor(Math.sqrt(xp / 100));
}

function getXPForLevel(level) {
    return level * level * 100;
}

function createProgressBar(current, total, length = 10) {
    const filled = Math.floor((current / total) * length);
    const empty = length - filled;
    return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
}

function getUserStats(userId) {
    initUser(userId); // Crea l'utente se non esiste
    return userStats[userId]; // Restituisci direttamente l'oggetto
}

// Listener per richieste di ingresso gruppo
client.on('group_join_request', async (notification) => {
    try {
        const groupId = notification.chatId;
        
        if (autoAcceptRequests[groupId]) {
            await notification.approve();
            console.log(`‚úÖ Richiesta accettata automaticamente per ${groupId}`);
        }
    } catch (err) {
        console.error('Errore accettazione richiesta:', err);
    }
});

function formatTime(seconds) {
    const d = Math.floor(seconds / 86400);
    const h = Math.floor((seconds % 86400) / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    let result = '';
    if (d > 0) result += `${d}g `;
    if (h > 0) result += `${h}h `;
    if (m > 0) result += `${m}m `;
    if (s > 0) result += `${s}s`;
    return result.trim();
}

// ---------------------- MESSAGGI ----------------------
client.on('message', async (msg) => {
    try {
        const chat = await msg.getChat();
        const isGroup = chat.isGroup;
        if (isGroup) initGroup(chat.id._serialized);
        const groupInfo = isGroup ? groupData[chat.id._serialized] : null;
        const automod = isGroup ? automodConfig[chat.id._serialized] : null;
        const userNumber = await getNormalizedNumber(msg);
        const userId = getUserIdFromMsg(msg);

        // Sistema XP e messaggi
        if (isGroup && groupInfo?.levelSystem) {
            userStats[userId] = userStats[userId] || { messages: 0 };
            userStats[userId].messages++;
            if (addXP(userId, Math.floor(Math.random() * 5) + 1)) {
                await msg.reply(`üéâüéä *LEVEL UP!* üéäüéâ\n\nüèÜ Sei ora livello *${userStats[userId].level}*!\n‚≠ê Continua cos√¨ campione!`);
            }
        }

        // Utenti mutati - controlla sia numero che ID completo
        const isMuted = groupInfo?.mutedUsers?.some(id => 
            id === userId || id.split('@')[0] === userNumber
        );
        if (isMuted) {
            try { 
                await msg.delete(true); 
                return;
            } catch (err) {
                console.log('Errore eliminazione messaggio mutato:', err);
            }
        }

        // Utenti bannati
        const isBanned = groupInfo?.bannedUsers?.some(id => 
            id === userId || id.split('@')[0] === userNumber
        );
        if (isBanned) {
            if (await isBotAdmin(chat)) {
                try { 
                    await chat.removeParticipants([msg.author]); 
                    return;
                } catch (err) {
                    console.log('Errore rimozione utente bannato:', err);
                }
            }
        }

        // Anti-link
        if (groupInfo?.antilink && /https?:\/\/|www\.|wa\.me|whatsapp\.com/i.test(msg.body || '')) {
            if (!(await isAdmin(msg, chat))) {
                try { 
                    await msg.delete(true); 
                    await msg.reply('‚ö†Ô∏èüîó *ANTILINK ATTIVO*\n\nI link non sono permessi in questo gruppo!');
                    return;
                } catch (err) {
                    console.log('Errore antilink:', err);
                }
            }
        }

        // Anti-bot
        if (groupInfo?.antiBot && msg.fromMe === false) {
            const contact = await msg.getContact();
            if (contact.isWAContact === false || contact.isBusiness) {
                if (!(await isAdmin(msg, chat))) {
                    try {
                        await chat.removeParticipants([msg.author]);
                        await msg.reply('ü§ñ‚ùå Bot rilevato e rimosso automaticamente!');
                        return;
                    } catch (err) {
                        console.log('Errore antibot:', err);
                    }
                }
            }
        }

        // Slowmode
        if (groupInfo?.slowmode > 0) {
            const lastMsg = groupInfo.lastMessage?.[userNumber] || 0;
            if (Date.now() - lastMsg < groupInfo.slowmode * 1000) {
                try { 
                    await msg.delete(true); 
                    return;
                } catch {}
            }
            groupInfo.lastMessage = groupInfo.lastMessage || {};
            groupInfo.lastMessage[userNumber] = Date.now();
        }

        // Parole vietate
        if ((msg.body || '').length > 0 && (groupInfo?.blockedWords || []).some(w => (msg.body || '').toLowerCase().includes(w.toLowerCase()))) {
            try { 
                await msg.delete(true); 
                await msg.reply('‚ö†Ô∏èüö´ Hai usato una parola vietata!');
                return;
            } catch {}
        }

        // Anti-flood
        if (automod?.antiFlood) {
            groupInfo.messageCount = groupInfo.messageCount || {};
            if (!groupInfo.messageCount[userNumber]) groupInfo.messageCount[userNumber] = [];
            
            groupInfo.messageCount[userNumber].push(Date.now());
            groupInfo.messageCount[userNumber] = groupInfo.messageCount[userNumber].filter(t => Date.now() - t < automod.timeWindow * 1000);
            
            if (groupInfo.messageCount[userNumber].length > automod.maxMessages) {
                if (!(await isAdmin(msg, chat))) {
                    try {
                        await msg.delete(true);
                        await msg.reply(`‚ö†Ô∏èüí• *FLOOD RILEVATO!*\n\n@${userNumber} stai inviando troppi messaggi!`);
                        groupInfo.messageCount[userNumber] = [];
                    } catch {}
                }
            }
        }

             

        // ---------------------- COMANDI ----------------------
if (!msg.body || !msg.body.startsWith('.')) return;

const args = msg.body.slice(1).trim().split(/ +/);
const command = (args.shift() || '').toLowerCase();
const text = msg.body.slice(1); // se ti serve il testo intero senza il punto

// ---------- CONTROLLO MODALIT√Ä ADMIN (POSIZIONE CORRETTA) ----------
        if (isGroup && groupData[chat.id._serialized]?.adminMode) {
            const isUserAdmin = await isAdmin(msg, chat); // OK perch√© sei in funzione async
            if (!isUserAdmin && command !== 'modoadmin') return; // esce dall'handler
        }     

// ================= FUNZIONE FALLBACK =================
async function sendListOrFallback(client, to, text, sections, buttonText, title) {
  try {
    const list = new List(text, buttonText, sections, title, 'Scegli un\'opzione');
    await client.sendMessage(to, list);
  } catch (err) {
    // Se il list non √® supportato, invia il testo normale come fallback
    let fallbackText = `${text}\n\nüìÇ *MENU DISPONIBILE:*\n`;
    for (const section of sections) {
      fallbackText += `\n${section.title}\n`;
      for (const row of section.rows) {
        fallbackText += `‚Ä¢ ${row.id} ‚Üí ${row.description}\n`;
      }
    }
    await client.sendMessage(to, fallbackText);
  }
}

// ========== MENU PRINCIPALE ==========
        if (['menu', 'help', 'comandi'].includes(command)) {
            const menuText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ü§ñ *BOT WHATSAPP*   ‚ïë
‚ïë  *MENU PRINCIPALE*    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìã *USA I PULSANTI SOTTO PER NAVIGARE*

üéØ *COMANDI RAPIDI:*
‚Ä¢ .moderazione - Gestisci gruppo üëÆ
‚Ä¢ .economia - Sistema economico üí∞
‚Ä¢ .giochi - Giochi disponibili üéÆ
‚Ä¢ .fun - Comandi divertenti üé™

üìä *STATISTICHE:*
‚Ä¢ .level - Il tuo livello üèÜ
‚Ä¢ .profilo - Il tuo profilo üë§
‚Ä¢ .top - Classifiche üèÖ

‚ùì *AIUTO:*
‚Ä¢ .help [comando] - Info comando
‚Ä¢ .info - Info sul bot
‚Ä¢ .ping - Testa il bot

üí° *SUGGERIMENTO:*
Usa i pulsanti qui sotto per navigare rapidamente nei menu!

üîß *Versione Bot:* 2.0 Premium
‚è∞ *Uptime:* ${formatTime(Math.floor((Date.now() - startTime) / 1000))}
`;

            const sections = [
                {
                    title: 'üëÆ MODERAZIONE',
                    rows: [
                        { id: '.moderazione', title: 'üëÆ Moderazione', description: 'Comandi admin e moderazione' },
                        { id: '.automod', title: 'üõ°Ô∏è Auto-Moderazione', description: 'Sistema automatico' }
                    ]
                },
                {
                    title: 'üí∞ SISTEMA',
                    rows: [
                        { id: '.economia', title: 'üí∞ Economia', description: 'Soldi, lavoro, banca' },
                        { id: '.giochi', title: 'üéÆ Giochi', description: 'Slot, quiz, indovina' }
                    ]
                },
                {
                    title: 'üéâ EXTRA',
                    rows: [
                        { id: '.fun', title: 'üé™ Fun & Social', description: 'Comandi divertenti' },
                    ]
                }
            ];

            // Invia menu interattivo o fallback testuale
            await sendListOrFallback(client, msg.from, menuText, sections, 'üìã Seleziona Menu', 'ü§ñ Bot Menu');
            return;
        }

        // ========== MENU MODERAZIONE ==========
        else if (command === 'moderazione' || command === 'mod') {
            const modText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üëÆ *MODERAZIONE*     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë• *GESTIONE UTENTI:*
‚Ä¢ .kick @user - üë¢ Rimuovi utente
‚Ä¢ .muta @user [tempo] - üîá Muta utente
‚Ä¢ .smuta @user - üîä Smuta utente
‚Ä¢ .warn @user [motivo] - ‚ö†Ô∏è Avvisa utente
‚Ä¢ .unwarn @user - ‚úÖ Rimuovi warn
‚Ä¢ .warnings @user - üìã Vedi warns
‚Ä¢ .clearwarns @user - üóëÔ∏è Cancella warns

üëë *GESTIONE ADMIN:*
‚Ä¢ .p @user - üëë Promuovi admin
‚Ä¢ .d @user - üë§ Degrada admin
‚Ä¢ .admins - üë• Lista admin
‚Ä¢ .promote-all - üëë Promuovi tutti
‚Ä¢ .demote-all - üë§ Degrada tutti

üõ°Ô∏è *PROTEZIONE GRUPPO:*
‚Ä¢ .antilink on/off - üîó Blocca link
‚Ä¢ .antibot on/off - ü§ñ Blocca bot
‚Ä¢ .antispam on/off - üí• Anti spam
‚Ä¢ .antiraid on/off - üõ°Ô∏è Anti raid
‚Ä¢ .slowmode [sec] - ‚è±Ô∏è Rallenta chat
‚Ä¢ .lock - üîí Blocca impostazioni
‚Ä¢ .unlock - üîì Sblocca impostazioni

üìù *CONTENUTI:*
‚Ä¢ .blocca [parola] - üö´ Blocca parola
‚Ä¢ .sblocca [parola] - ‚úÖ Sblocca parola
‚Ä¢ .listaparole - üìã Lista parole bloccate
‚Ä¢ .r - üóëÔ∏è Elimina messaggio quotato

‚öôÔ∏è *CONFIGURAZIONE:*
‚Ä¢ .regole [testo] - üìú Imposta regole
‚Ä¢ .vediregole - üìñ Visualizza regole
‚Ä¢ .chiudi - üîí Solo admin scrivono
‚Ä¢ .apri - üîì Tutti scrivono
‚Ä¢ .setwelcome [msg] - üëã Messaggio benvenuto
‚Ä¢ .setgoodbye [msg] - üëã Messaggio addio
‚Ä¢ .setmaxwarns [num] - ‚ö†Ô∏è Max warn prima ban

üìä *INFORMAZIONI:*
‚Ä¢ .info - üìä Info gruppo
‚Ä¢ .mutati - üîá Lista utenti mutati
‚Ä¢ .bannati - üö´ Lista utenti bannati
‚Ä¢ .attivita - üìà Attivit√† gruppo

üéØ *AZIONI RAPIDE:*
‚Ä¢ .tag [msg] - üì¢ Tagga tutti
‚Ä¢ .hidetag [msg] - üëª Tag nascosto
‚Ä¢ .purge [num] - üóëÔ∏è Elimina messaggi
‚Ä¢ .pin - üìå Fissa messaggio
‚Ä¢ .unpin - üìå Togli fissa

üí° *SUGGERIMENTO:*
Usa .automod per configurare la moderazione automatica!
`;
            await msg.reply(modText);
            return;
        }

// ========== MENU AUTO-MODERAZIONE ==========
if (command === 'automod' || command === 'automoderatore') {
  if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
  if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
  
  const automodText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üõ°Ô∏è *AUTO-MOD*       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

*STATO ATTUALE:*
üîó Antilink: ${groupInfo.antilink ? '‚úÖ ON' : '‚ùå OFF'}
ü§ñ Antibot: ${groupInfo.antiBot ? '‚úÖ ON' : '‚ùå OFF'}
üí• Antispam: ${groupInfo.antiSpam ? '‚úÖ ON' : '‚ùå OFF'}
üõ°Ô∏è Antiraid: ${automod?.antiRaid ? '‚úÖ ON' : '‚ùå OFF'}
üí• Antiflood: ${automod?.antiFlood ? '‚úÖ ON' : '‚ùå OFF'}
‚è±Ô∏è Slowmode: ${groupInfo.slowmode}s
‚ö†Ô∏è Max Warns: ${groupInfo.maxWarns}

*COMANDI CONFIGURAZIONE:*
‚Ä¢ .antilink on/off - Attiva/disattiva antilink
‚Ä¢ .antibot on/off - Attiva/disattiva antibot
‚Ä¢ .antispam on/off - Attiva/disattiva antispam
‚Ä¢ .antiraid on/off - Attiva/disattiva antiraid
‚Ä¢ .antiflood on/off [msg] [sec] - Config antiflood
‚Ä¢ .slowmode [secondi] - Imposta slowmode
‚Ä¢ .setmaxwarns [numero] - Max warn

*ESEMPIO ANTIFLOOD:*
.antiflood on 5 10
(Max 5 messaggi in 10 secondi)
`;
  await msg.reply(automodText);
  return;
}

// ========== MENU ECONOMIA ==========
if (command === 'economia' || command === 'eco') {
  const ecoText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üí∞ *ECONOMIA*        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

.soldi - Vedi saldo
.daily - Bonus giornaliero
.lavora - Lavora per soldi
.weekly - Bonus settimanale
.monthly - Bonus mensile
.regalo @user [amt] - Dona soldi
.ruba @user - Ruba soldi
.deposita [amt] - Deposita in banca
.preleva [amt] - Preleva da banca
.crimine - Commetti crimine
.scommessa [amt] - Scommetti
.multiplica [amt] - Moltiplica soldi
.investimento [amt] - Investi
.prestito [amt] - Chiedi prestito
.ripaga - Ripaga prestito

`;
  await msg.reply(ecoText);
  return;
}

// ========== MENU GIOCHI ==========
if (command === 'giochi' || command === 'games') {
  const gamesText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üéÆ *GIOCHI*          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

.rps [scelta] - Morra cinese
.slot - Slot machine
.indovina [num] - Indovina numero
.8ball [domanda] - Palla magica
.scelta op1|op2 - Scegli random
.dado - Lancia dado
.moneta - Lancia moneta
.blackjack - Gioca blackjack
.roulette [color/num] - Roulette
.quiz - Quiz random
.trivia - Trivia
.math - Matematica veloce
.memory - Gioco memoria
.tictactoe @user - Tris
.impiccato - Impiccato
.indovinachi - Indovina personaggio
.creacoppia
.ship (user1) (user2)
.amore
`;
  await msg.reply(gamesText);
  return;
}

// ========== MENU FUN ==========
if (command === 'fun' || command === 'divertimento') {
  const funText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üé™ *FUN & SOCIAL*    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

.meme - Meme random
.fact - Fatto random
.quote - Citazione
.joke - Barzelletta
.consiglio - Consiglio random
.sfida @user - Sfida utente
.complimento @user - Complimento
.insulta @user - Insulta (fun)
.amore @user - Calcolatore amore
.ship @user1 @user2 - Shippa due user
.faketext [testo] - Testo fake
.ascii [testo] - Testo ASCII
.reverse [testo] - Testo invertito
.caps [testo] - MAIUSCOLO
.mock [testo] - tEsTo AlTeRnAtO
`;
  await msg.reply(funText);
  return;
}


       // COMANDO: .tag / .tagall
else if (command === 'tag' || command === 'tagall') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');

    const messageText = args.join(' ').trim() || 'üì¢ Attenzione!';
    const mentions = [];

    // Raccogli tutti i contatti per le menzioni
    for (let participant of chat.participants) {
        try {
            const contact = await client.getContactById(participant.id._serialized);
            mentions.push(contact);
        } catch (e) {
            // Se non riesce a ottenere il contatto, salta
            console.log('Impossibile ottenere contatto:', participant.id ? participant.id._serialized : participant);
        }
    }

    // Se il comando √® stato inviato come risposta, recupera il messaggio quotato
    let quotedMsgObj = null;
    if (msg.hasQuotedMsg) {
        try {
            quotedMsgObj = await msg.getQuotedMessage();
        } catch (e) {
            console.log('Errore recupero messaggio quotato:', e);
            quotedMsgObj = null;
        }
    }

    try {
        // Se esiste un messaggio quotato: invia il messaggio taggando tutti e quotando quel messaggio
        if (quotedMsgObj) {
            // Invia il testo (puoi includere anche il corpo del messaggio quotato se vuoi)
            await chat.sendMessage(messageText, { mentions, quoted: quotedMsgObj });
        } else {
            // Nessuna risposta: invia normalmente taggando tutti
            await chat.sendMessage(messageText, { mentions });
        }
    } catch (err) {
        console.error('Errore comando .tag:', err);
        await msg.reply('‚ùå Errore durante il tag di tutti i membri.');
    }
}

// HIDETAG - Tag nascosto
else if (command === 'hidetag') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    try {
        const text = args.join(' ') || 'üëª Messaggio nascosto';
        const mentions = chat.participants.map(p => p.id._serialized);
        
        await chat.sendMessage(text, { mentions });
        
    } catch (err) {
        console.error('Errore hidetag:', err);
        await msg.reply('‚ùå Errore durante l\'invio del messaggio nascosto.');
    }
}



// KICK UTENTE
else if (command === 'kick' || command === 'remove') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    if (!await isBotAdmin(chat)) return msg.reply('‚ö†Ô∏è Il bot deve essere admin per rimuovere utenti!');
    
    const mentioned = await msg.getMentions();
    if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona un utente da rimuovere!\n\nüí° Esempio: `.kick @utente`');
    
    try {
        const toKickNumber = mentioned[0].id._serialized.split('@')[0];
        const toKickName = mentioned[0].pushname || toKickNumber;
        
        const freshChat = await client.getChatById(chat.id._serialized);
        const participant = freshChat.participants.find(
            p => p.id._serialized.split('@')[0] === toKickNumber
        );
        
        if (!participant) {
            return msg.reply('‚ùå Utente non trovato nel gruppo!');
        }
        
        await chat.removeParticipants([participant.id._serialized]);
        
        await msg.reply(
            `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üë¢ *UTENTE RIMOSSO*  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${toKickName}*
üì± Numero: ${toKickNumber}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
L'utente √® stato espulso dal gruppo.`
        );
        
    } catch (err) {
        console.error('Errore kick:', err);
        await msg.reply('‚ùå Errore durante la rimozione. Verifica che il bot sia admin.');
    }
}

// MUTA UTENTE (con sistema migliorato)
else if (command === 'muta' || command === 'mute') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    if (!await isBotAdmin(chat)) return msg.reply('‚ö†Ô∏è Il bot deve essere admin per eliminare messaggi!');
    
    const mentioned = await msg.getMentions();
    if (mentioned.length === 0) {
        return msg.reply(
            '‚ö†Ô∏è Menziona un utente da mutare!\n\n' +
            'üí° *Esempi:*\n' +
            '‚Ä¢ `.muta @utente` - Mute permanente\n' +
            '‚Ä¢ `.muta @utente 30` - Mute per 30 minuti'
        );
    }
    
    try {
        const toMuteId = mentioned[0].id._serialized;
        const toMuteNumber = toMuteId.split('@')[0];
        const toMuteName = mentioned[0].pushname || toMuteNumber;
        const muteTime = parseInt(args[args.length - 1]);
        
        initGroup(chat.id._serialized);
        
        // Verifica se gi√† mutato
        const alreadyMuted = groupData[chat.id._serialized].mutedUsers.some(
            id => id === toMuteId || id.split('@')[0] === toMuteNumber
        );
        
        if (alreadyMuted) {
            return msg.reply(`‚ö†Ô∏è *${toMuteName}* √® gi√† mutato!`);
        }
        
        // Aggiungi alla lista mutati
        groupData[chat.id._serialized].mutedUsers.push(toMuteId);
        
        // Gestione mute temporaneo
        if (!isNaN(muteTime) && muteTime > 0) {
            const unmuteTime = Date.now() + (muteTime * 60 * 1000);
            
            if (!groupData[chat.id._serialized].muteTime) {
                groupData[chat.id._serialized].muteTime = {};
            }
            groupData[chat.id._serialized].muteTime[toMuteId] = unmuteTime;
            
            // Timeout per unmute automatico
            setTimeout(async () => {
                try {
                    const idx = groupData[chat.id._serialized].mutedUsers.findIndex(
                        id => id === toMuteId || id.split('@')[0] === toMuteNumber
                    );
                    if (idx !== -1) {
                        groupData[chat.id._serialized].mutedUsers.splice(idx, 1);
                        delete groupData[chat.id._serialized].muteTime[toMuteId];
                        saveData();
                        
                        await client.sendMessage(
                            chat.id._serialized,
                            `üîä *${toMuteName}* √® stato automaticamente smutato!`
                        );
                    }
                } catch (err) {
                    console.error('Errore unmute automatico:', err);
                }
            }, muteTime * 60 * 1000);
            
            saveData();
            
            await msg.reply(
                `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üîá *UTENTE MUTATO*   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${toMuteName}*
üì± Numero: ${toMuteNumber}
‚è±Ô∏è Durata: *${muteTime} minuti*

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö†Ô∏è Tutti i suoi messaggi saranno eliminati automaticamente.
üîä Sar√† smutato automaticamente tra ${muteTime} minuti.`
            );
            
        } else {
            saveData();
            
            await msg.reply(
                `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üîá *UTENTE MUTATO*   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${toMuteName}*
üì± Numero: ${toMuteNumber}
‚è±Ô∏è Durata: *PERMANENTE*

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö†Ô∏è Tutti i suoi messaggi saranno eliminati automaticamente.
üí° Usa \`.smuta @utente\` per rimuovere il mute.`
            );
        }
        
    } catch (err) {
        console.error('Errore muta:', err);
        await msg.reply('‚ùå Errore durante il mute. Verifica che il bot sia admin.');
    }
}

else if (command === 'modoadmin' || command === 'adminmode') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
    
    const status = args[0]?.toLowerCase();
    if (!['on', 'off'].includes(status)) {
        initGroup(chat.id._serialized);
        const currentStatus = groupData[chat.id._serialized].adminMode ? '‚úÖ ON' : '‚ùå OFF';
        return msg.reply(`‚öôÔ∏è üëë *MODO ADMIN*\n\nStato: ${currentStatus}\n\nQuando attivo, solo gli admin possono usare i comandi.\n\nUsa: .modoadmin on/off`);
    }
    
    initGroup(chat.id._serialized);
    groupData[chat.id._serialized].adminMode = (status === 'on');
    saveData();
    await msg.reply(`‚úÖ üëë Modo Admin ${status === 'on' ? '*ATTIVATO*' : '*DISATTIVATO*'}!`);
}

else if (command === 'attivita' || command === 'activity') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
    
    initGroup(chat.id._serialized);
    const g = groupData[chat.id._serialized];
    
    const totalMessages = Object.values(userStats)
        .filter(u => u.messages > 0)
        .reduce((sum, u) => sum + u.messages, 0);
    
    const activeUsers = Object.keys(userStats).filter(id => userStats[id].messages > 0).length;
    
    await msg.reply(
        `üìà *ATTIVIT√Ä GRUPPO*\n\n` +
        `üë• Utenti attivi: *${activeUsers}*\n` +
        `üí¨ Messaggi totali: *${totalMessages}*\n` +
        `‚ö†Ô∏è Utenti mutati: *${g.mutedUsers.length}*\n` +
        `üö´ Utenti bannati: *${g.bannedUsers.length}*\n` +
        `üõ°Ô∏è Antilink: ${g.antilink ? '‚úÖ' : '‚ùå'}\n` +
        `ü§ñ Antibot: ${g.antiBot ? '‚úÖ' : '‚ùå'}\n` +
        `‚è±Ô∏è Slowmode: ${g.slowmode}s`
    );
}

// SMUTA UTENTE
else if (command === 'smuta' || command === 'unmute') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    const mentioned = await msg.getMentions();
    if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona un utente da smutare!\n\nüí° Esempio: `.smuta @utente`');
    
    try {
        const toUnmuteId = mentioned[0].id._serialized;
        const toUnmuteNumber = toUnmuteId.split('@')[0];
        const toUnmuteName = mentioned[0].pushname || toUnmuteNumber;
        
        initGroup(chat.id._serialized);
        const idx = groupData[chat.id._serialized].mutedUsers.findIndex(
            id => id === toUnmuteId || id.split('@')[0] === toUnmuteNumber
        );
        
        if (idx === -1) {
            return msg.reply(`‚ö†Ô∏è *${toUnmuteName}* non √® mutato!`);
        }
        
        groupData[chat.id._serialized].mutedUsers.splice(idx, 1);
        
        // Rimuovi anche il tempo se presente
        if (groupData[chat.id._serialized].muteTime?.[toUnmuteId]) {
            delete groupData[chat.id._serialized].muteTime[toUnmuteId];
        }
        
        saveData();
        
        await msg.reply(
            `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üîä *UTENTE SMUTATO*  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${toUnmuteName}*
üì± Numero: ${toUnmuteNumber}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ L'utente pu√≤ ora scrivere liberamente.`
        );
        
    } catch (err) {
        console.error('Errore smuta:', err);
        await msg.reply('‚ùå Errore durante lo smute.');
    }
}

// WARN UTENTE
else if (command === 'warn') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    const mentioned = await msg.getMentions();
    if (mentioned.length === 0) {
        return msg.reply(
            '‚ö†Ô∏è Menziona un utente da avvisare!\n\n' +
            'üí° *Esempio:*\n' +
            '`.warn @utente Spam nel gruppo`'
        );
    }
    
    try {
        const userId = mentioned[0].id._serialized;
        const userName = mentioned[0].pushname || userId.split('@')[0];
        const reason = args.slice(1).join(' ') || 'Nessun motivo specificato';
        
        initGroup(chat.id._serialized);
        const g = groupData[chat.id._serialized];
        
        g.warnings[userId] = (g.warnings[userId] || 0) + 1;
        saveData();
        
        const warnCount = g.warnings[userId];
        const maxWarns = g.maxWarns || 3;
        
        // Calcola barra di avanzamento warns
        const progressBar = '‚ñà'.repeat(warnCount) + '‚ñë'.repeat(maxWarns - warnCount);
        
        await msg.reply(
            `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚ö†Ô∏è *WARNING ISSUED*  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${userName}*
üìä Warn: *${warnCount}/${maxWarns}*
${progressBar}

üí¨ *Motivo:*
${reason}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${warnCount >= maxWarns ? 'üö® LIMITE RAGGIUNTO! Utente verr√† rimosso.' : `‚ö†Ô∏è Ancora ${maxWarns - warnCount} warn prima della rimozione.`}`
        );
        
        // Auto-kick se raggiunto il limite
        if (warnCount >= maxWarns) {
            try {
                await chat.removeParticipants([userId]);
                await msg.reply(`üö´ *${userName}* √® stato rimosso per troppi warning!`);
                delete g.warnings[userId];
                saveData();
            } catch (err) {
                console.error('Errore auto-kick:', err);
            }
        }
        
    } catch (err) {
        console.error('Errore warn:', err);
        await msg.reply('‚ùå Errore durante l\'invio del warning.');
    }
}

// UNWARN UTENTE
else if (command === 'unwarn') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    const mentioned = await msg.getMentions();
    if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona un utente!\n\nüí° Esempio: `.unwarn @utente`');
    
    try {
        const userId = mentioned[0].id._serialized;
        const userName = mentioned[0].pushname || userId.split('@')[0];
        
        initGroup(chat.id._serialized);
        const g = groupData[chat.id._serialized];
        
        if (!g.warnings[userId] || g.warnings[userId] === 0) {
            return msg.reply(`‚ö†Ô∏è *${userName}* non ha warning attivi!`);
        }
        
        g.warnings[userId]--;
        saveData();
        
        const warnCount = g.warnings[userId];
        const maxWarns = g.maxWarns || 3;
        const progressBar = '‚ñà'.repeat(warnCount) + '‚ñë'.repeat(maxWarns - warnCount);
        
        await msg.reply(
            `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚úÖ *WARNING RIMOSSO* ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${userName}*
üìä Warn: *${warnCount}/${maxWarns}*
${progressBar}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Un warning √® stato rimosso con successo.`
        );
        
    } catch (err) {
        console.error('Errore unwarn:', err);
        await msg.reply('‚ùå Errore durante la rimozione del warning.');
    }
}

// VISUALIZZA WARNINGS
else if (command === 'warnings') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    const userId = getUserIdFromMsg(msg); // AGGIUNGI QUESTA RIGA
    const mentioned = await msg.getMentions();
    const targetId = mentioned.length > 0 ? mentioned[0].id._serialized : userId;
    const targetName = mentioned.length > 0 
        ? (mentioned[0].pushname || mentioned[0].number) 
        : 'Tu';
    
    initGroup(chat.id._serialized);
    const g = groupData[chat.id._serialized];
    
    const warnCount = g.warnings[targetId] || 0;
    const maxWarns = g.maxWarns || 3;
    const progressBar = '‚ñà'.repeat(warnCount) + '‚ñë'.repeat(maxWarns - warnCount);
    
    let status = '';
    if (warnCount === 0) status = '‚úÖ Nessun warning';
    else if (warnCount < maxWarns / 2) status = '‚ö†Ô∏è Attenzione';
    else if (warnCount < maxWarns) status = 'üö® Pericolo';
    else status = 'üî¥ Critico';
    
    await msg.reply(
        `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üìã *WARNINGS*        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${targetName}*
üìä Warn: *${warnCount}/${maxWarns}*
${progressBar}

üìå Status: ${status}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${warnCount >= maxWarns ? '‚ö†Ô∏è Limite raggiunto! Prossimo warn = kick' : `üí° Ancora ${maxWarns - warnCount} warn disponibili`}`
    );
}

// CLEAR WARNINGS
else if (command === 'clearwarns') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    const mentioned = await msg.getMentions();
    if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona un utente!\n\nüí° Esempio: `.clearwarns @utente`');
    
    try {
        const userId = mentioned[0].id._serialized;
        const userName = mentioned[0].pushname || userId.split('@')[0];
        
        initGroup(chat.id._serialized);
        const g = groupData[chat.id._serialized];
        
        const previousWarns = g.warnings[userId] || 0;
        g.warnings[userId] = 0;
        saveData();
        
        await msg.reply(
            `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üóëÔ∏è *WARNS CANCELLATI*‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üë§ Utente: *${userName}*
üìä Warn precedenti: *${previousWarns}*
‚ú® Warn attuali: *0*

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ Tutti i warning sono stati rimossi!`
        );
        
    } catch (err) {
        console.error('Errore clearwarns:', err);
        await msg.reply('‚ùå Errore durante la cancellazione dei warning.');
    }
}

        else if (command === 'antilink') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const status = args[0] ? args[0].toLowerCase() : null;
            if (!['on', 'off'].includes(status)) {
                initGroup(chat.id._serialized);
                const currentStatus = groupData[chat.id._serialized].antilink ? '‚úÖ ON' : '‚ùå OFF';
                return msg.reply(`‚öôÔ∏è üîó *ANTILINK*\n\nStato: ${currentStatus}\n\nUsa: .antilink on/off`);
            }
            initGroup(chat.id._serialized);
            groupData[chat.id._serialized].antilink = (status === 'on');
            saveData();
            await msg.reply(`‚úÖ üîó Antilink ${status === 'on' ? '*ATTIVATO*' : '*DISATTIVATO*'}!`);
        }

        else if (command === 'antibot') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const status = args[0] ? args[0].toLowerCase() : null;
            if (!['on', 'off'].includes(status)) {
                initGroup(chat.id._serialized);
                const currentStatus = groupData[chat.id._serialized].antiBot ? '‚úÖ ON' : '‚ùå OFF';
                return msg.reply(`‚öôÔ∏è ü§ñ *ANTIBOT*\n\nStato: ${currentStatus}\n\nUsa: .antibot on/off`);
            }
            initGroup(chat.id._serialized);
            groupData[chat.id._serialized].antiBot = (status === 'on');
            saveData();
            await msg.reply(`‚úÖ ü§ñ Antibot ${status === 'on' ? '*ATTIVATO*' : '*DISATTIVATO*'}!`);
        }

        else if (command === 'antispam') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const status = args[0]?.toLowerCase();
            if (!['on', 'off'].includes(status)) return msg.reply('‚ö†Ô∏è Usa: .antispam on/off');
            initGroup(chat.id._serialized);
            groupData[chat.id._serialized].antiSpam = (status === 'on');
            saveData();
            await msg.reply(`‚úÖ üí• Anti-spam ${status === 'on' ? '*ATTIVATO*' : '*DISATTIVATO*'}!`);
        }

        else if (command === 'antiflood') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const status = args[0]?.toLowerCase();
            if (!['on', 'off'].includes(status)) return msg.reply('‚ö†Ô∏è Usa: .antiflood on/off [maxMsg] [secondi]');
            initGroup(chat.id._serialized);
            automodConfig[chat.id._serialized].antiFlood = (status === 'on');
            if (status === 'on') {
                const maxMsg = parseInt(args[1]) || 5;
                const timeWindow = parseInt(args[2]) || 10;
                automodConfig[chat.id._serialized].maxMessages = maxMsg;
                automodConfig[chat.id._serialized].timeWindow = timeWindow;
            }
            saveData();
            await msg.reply(`‚úÖ üí• Antiflood ${status === 'on' ? `*ATTIVATO*\n\nüìä Max messaggi: ${automodConfig[chat.id._serialized].maxMessages}\n‚è±Ô∏è Finestra: ${automodConfig[chat.id._serialized].timeWindow}s` : '*DISATTIVATO*'}!`);
        }

        else if (command === 'slowmode') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const seconds = parseInt(args[0]);
            if (isNaN(seconds) || seconds < 0) {
                return msg.reply('‚ö†Ô∏è Usa: .slowmode [secondi] (0 per disattivare)');
            }
            initGroup(chat.id._serialized);
            groupData[chat.id._serialized].slowmode = seconds;
            saveData();
            await msg.reply(`‚úÖ ‚è±Ô∏è Slowmode ${seconds === 0 ? '*DISATTIVATO*' : `impostato a *${seconds}s*`}!`);
        }

        else if (command === 'blocca' || command === 'blockword') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const word = args.join(' ').toLowerCase();
            if (!word) return msg.reply('‚ö†Ô∏è Specifica una parola!');
            initGroup(chat.id._serialized);
            if (!groupData[chat.id._serialized].blockedWords.includes(word)) {
                groupData[chat.id._serialized].blockedWords.push(word);
                saveData();
                await msg.reply(`‚úÖ üö´ Parola *"${word}"* bloccata!`);
            } else {
                await msg.reply('‚ö†Ô∏è Parola gi√† bloccata!');
            }
        }

        else if (command === 'sblocca' || command === 'unblockword') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const word = args.join(' ').toLowerCase();
            if (!word) return msg.reply('‚ö†Ô∏è Specifica una parola!');
            initGroup(chat.id._serialized);
            const idx = groupData[chat.id._serialized].blockedWords.indexOf(word);
            if (idx !== -1) {
                groupData[chat.id._serialized].blockedWords.splice(idx, 1);
                saveData();
                await msg.reply(`‚úÖ Parola *"${word}"* sbloccata!`);
            } else {
                await msg.reply('‚ö†Ô∏è Parola non era bloccata!');
            }
        }

        else if (command === 'listaparole') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            initGroup(chat.id._serialized);
            const words = groupData[chat.id._serialized].blockedWords;
            if (words.length === 0) return msg.reply('üìã Nessuna parola bloccata!');
            await msg.reply(`üìã *PAROLE BLOCCATE* (${words.length})\n\n${words.map((w, i) => `${i + 1}. ${w}`).join('\n')}`);
        }

        else if (command === 'regole' || command === 'setrules') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const rules = args.join(' ');
            if (!rules) return msg.reply('‚ö†Ô∏è Usa: .regole [testo regole]');
            initGroup(chat.id._serialized);
            groupData[chat.id._serialized].rules = rules;
            saveData();
            await msg.reply('‚úÖ üìú Regole impostate con successo!');
        }

        else if (command === 'vediregole' || command === 'rules') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            initGroup(chat.id._serialized);
            const rules = groupData[chat.id._serialized].rules;
            if (!rules) return msg.reply('‚ö†Ô∏è Nessuna regola impostata! Gli admin possono impostarle con .regole');
            await msg.reply(`üìú *REGOLE DEL GRUPPO*\n\n${rules}`);
        }

        else if (command === 'chiudi' || command === 'close') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            try {
                await chat.setMessagesAdminsOnly(true);
                await msg.reply('üîí *GRUPPO CHIUSO*\n\nSolo gli admin possono scrivere.');
            } catch {
                await msg.reply('‚ùå Errore! Assicurati che il bot sia admin.');
            }
        }

        else if (command === 'apri' || command === 'open') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            try {
                await chat.setMessagesAdminsOnly(false);
                await msg.reply('üîì *GRUPPO APERTO*\n\nTutti possono scrivere.');
            } catch {
                await msg.reply('‚ùå Errore! Assicurati che il bot sia admin.');
            }
        }

        else if (command === 'lock') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            try {
                await chat.setInfoAdminsOnly(true);
                await msg.reply('üîí *IMPOSTAZIONI BLOCCATE*\n\nSolo admin possono modificare info gruppo.');
            } catch {
                await msg.reply('‚ùå Errore! Assicurati che il bot sia admin.');
            }
        }

        else if (command === 'unlock') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            try {
                await chat.setInfoAdminsOnly(false);
                await msg.reply('üîì *IMPOSTAZIONI SBLOCCATE*\n\nTutti possono modificare info gruppo.');
            } catch {
                await msg.reply('‚ùå Errore! Assicurati che il bot sia admin.');
            }
        }

        else if (command === 'r' || command === 'delete') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            try {
                const quoted = await msg.getQuotedMessage();
                if (!quoted) return msg.reply('‚ö†Ô∏è Rispondi al messaggio da eliminare!');
                await quoted.delete(true);
                await msg.reply('‚úÖ üóëÔ∏è Messaggio eliminato!');
            } catch (err) {
                await msg.reply('‚ùå Errore nell\'eliminazione del messaggio.');
            }
        }

        else if (command === 'p' || command === 'promuovi' || command === 'promote') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const mentionedUsers = await msg.getMentions();
            if (mentionedUsers.length === 0) return msg.reply('‚ùå Menziona almeno un utente!');
            try {
                for (const user of mentionedUsers) {
                    await chat.promoteParticipants([user.id._serialized]);
                }
                await msg.reply(`‚úÖ üëë *${mentionedUsers.length}* utente/i promosso/i ad admin!`);
            } catch (err) {
                await msg.reply('‚ùå Errore nella promozione. Assicurati che il bot sia admin.');
            }
        }

        else if (command === 'd' || command === 'degrada' || command === 'demote') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const mentionedUsers = await msg.getMentions();
            if (mentionedUsers.length === 0) return msg.reply('‚ùå Menziona almeno un utente!');
            try {
                for (const user of mentionedUsers) {
                    await chat.demoteParticipants([user.id._serialized]);
                }
                await msg.reply(`‚úÖ üë§ *${mentionedUsers.length}* utente/i degradato/i.`);
            } catch (err) {
                await msg.reply('‚ùå Errore nel degrado. Assicurati che il bot sia admin.');
            }
        }

        else if (command === 'admins') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            const admins = chat.participants.filter(p => p.isAdmin || p.isSuperAdmin);
            let text = `üëë *LISTA ADMIN* (${admins.length})\n\n`;
            for (let i = 0; i < admins.length; i++) {
                const admin = admins[i];
                text += `${i + 1}. ${admin.id.user}\n`;
            }
            await msg.reply(text);
        }

        else if (command === 'mutati') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            initGroup(chat.id._serialized);
            const muted = groupData[chat.id._serialized].mutedUsers;
            if (muted.length === 0) return msg.reply('üìã Nessun utente mutato!');
            let text = `üîá *UTENTI MUTATI* (${muted.length})\n\n`;
            muted.forEach((id, i) => {
                text += `${i + 1}. ${id.split('@')[0]}\n`;
            });
            await msg.reply(text);
        }

        else if (command === 'bannati') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            initGroup(chat.id._serialized);
            const banned = groupData[chat.id._serialized].bannedUsers;
            if (banned.length === 0) return msg.reply('üìã Nessun utente bannato!');
            let text = `üö´ *UTENTI BANNATI* (${banned.length})\n\n`;
            banned.forEach((id, i) => {
                text += `${i + 1}. ${id.split('@')[0]}\n`;
            });
            await msg.reply(text);
        }

        else if (command === 'setmaxwarns') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Solo nei gruppi!');
            if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo admin!');
            const maxWarns = parseInt(args[0]);
            if (isNaN(maxWarns) || maxWarns < 1) return msg.reply('‚ö†Ô∏è Usa: .setmaxwarns [numero]');
            initGroup(chat.id._serialized);
            groupData[chat.id._serialized].maxWarns = maxWarns;
            saveData();
            await msg.reply(`‚úÖ ‚ö†Ô∏è Max warn impostato a *${maxWarns}*!`);
        }

        // ========== COMANDI ECONOMIA ==========
        else if (command === 'soldi' || command === 'balance' || command === 'bal') {
            initUser(userId);
            const bal = economy[userId];
            await msg.reply(`üí∞ *IL TUO PORTAFOGLIO*\n\nüíµ Contanti: *${bal.money}* coins\nüè¶ Banca: *${bal.bank}* coins\nüíé Totale: *${bal.money + bal.bank}* coins`);
        }

        else if (command === 'daily') {
            initUser(userId);
            const now = nowSeconds();
            const cooldown = 24 * 60 * 60;
            if (now - economy[userId].lastDaily < cooldown) {
                const remaining = cooldown - (now - economy[userId].lastDaily);
                const h = Math.floor(remaining / 3600);
                const m = Math.floor((remaining % 3600) / 60);
                return msg.reply(`‚è≥ Gi√† riscattato! Torna tra *${h}h ${m}m*.`);
            }
            const amount = 200 + Math.floor(Math.random() * 201);
            economy[userId].money += amount;
            economy[userId].lastDaily = now;
            saveData();
            await msg.reply(`‚úÖ *DAILY RISCATTATO!* üéâ\n\nHai ricevuto *${amount}* coins!`); 
        }

        else if (command === 'weekly') {
            initUser(userId);
            const now = nowSeconds();
            const cooldown = 7 * 24 * 60 * 60;
            if (now - economy[userId].lastWeekly < cooldown) {
                const remaining = cooldown - (now - economy[userId].lastWeekly);
                const d = Math.floor(remaining / 86400);
                const h = Math.floor((remaining % 86400) / 3600);
                return msg.reply(`‚è≥ Gi√† riscattato! Torna tra *${d}g ${h}h*.`);
            }
            const amount = 1000 + Math.floor(Math.random() * 1001);
            economy[userId].money += amount;
            economy[userId].lastWeekly = now;
            saveData();
            await msg.reply(`‚úÖ *WEEKLY RISCATTATO!* üéâ\n\nHai ricevuto *${amount}* coins!`);
        }

        else if (command === 'monthly') {
            initUser(userId);
            const now = nowSeconds();
            const cooldown = 30 * 24 * 60 * 60;
            if (now - economy[userId].lastMonthly < cooldown) {
                const remaining = cooldown - (now - economy[userId].lastMonthly);
                const d = Math.floor(remaining / 86400);
                return msg.reply(`‚è≥ Gi√† riscattato! Torna tra *${d}g*.`);
            }
            const amount = 3000 + Math.floor(Math.random() * 2001);
            economy[userId].money += amount;
            economy[userId].lastMonthly = now;
            saveData();
            await msg.reply(`‚úÖ *MONTHLY RISCATTATO!* üéâ\n\nHai ricevuto *${amount}* coins!`);
        }

        // ========== LAVORO & CRIMINE ==========
        else if (command === 'lavora') {
            initUser(userId);
            const now = nowSeconds();
            const cooldown = 60 * 60; // 1 ora
            if (now - economy[userId].lastWork < cooldown) {
                const remaining = cooldown - (now - economy[userId].lastWork);
                const m = Math.floor(remaining / 60);
                return msg.reply(`‚è≥ Hai gi√† lavorato! Torna tra *${m}m*.`);
            }
            const earnings = 50 + Math.floor(Math.random() * 201);
            economy[userId].money += earnings;
            economy[userId].lastWork = now;
            saveData();
            await msg.reply(`üíº Hai lavorato e guadagnato *${earnings}* coins!`);
        }

        else if (command === 'crimine') {
            initUser(userId);
            const now = nowSeconds();
            const cooldown = 2 * 60 * 60; // 2 ore
            if (now - economy[userId].lastCrime < cooldown) {
                const remaining = cooldown - (now - economy[userId].lastCrime);
                const m = Math.floor(remaining / 60);
                return msg.reply(`‚è≥ Hai gi√† tentato un crimine! Torna tra *${m}m*.`);
            }
            const success = Math.random() < 0.45;
            economy[userId].lastCrime = now;
            if (success) {
                const loot = 200 + Math.floor(Math.random() * 801);
                economy[userId].money += loot;
                saveData();
                await msg.reply(`üòà *CRIMINE RIESCIUTO!* Hai guadagnato *${loot}* coins!`);
            } else {
                const fine = Math.min(economy[userId].money, 150 + Math.floor(Math.random() * 351));
                economy[userId].money -= fine;
                saveData();
                await msg.reply(`üöî *FALLITO!* Sei stato beccato e hai perso *${fine}* coins come multa!`);
            }
        }

        else if (command === 'ruba') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Usa questo comando in un gruppo menzionando un utente.');
            const mentioned = await msg.getMentions();
            if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona un utente da cui rubare!');
            const target = mentioned[0];
            const targetId = target.id._serialized;
            initUser(userId);
            initUser(targetId);
            const now = nowSeconds();
            const cooldown = 30 * 60; // 30 minuti
            if (now - economy[userId].lastRob < cooldown) {
                const remaining = cooldown - (now - economy[userId].lastRob);
                const m = Math.floor(remaining / 60);
                return msg.reply(`‚è≥ Hai gi√† tentato di rubare! Torna tra *${m}m*.`);
            }
            economy[userId].lastRob = now;
            const success = Math.random() < 0.4;
            if (success && economy[targetId].money > 0) {
                const amount = Math.min(economy[targetId].money, 100 + Math.floor(Math.random() * 401));
                economy[targetId].money -= amount;
                economy[userId].money += amount;
                saveData();
                await msg.reply(`üïµÔ∏è‚Äç‚ôÇÔ∏è Rubato con successo *${amount}* coins da *${target.pushname || target.number}*!`);
            } else {
                const penalty = Math.min(economy[userId].money, 50 + Math.floor(Math.random() * 151));
                economy[userId].money -= penalty;
                saveData();
                await msg.reply(`üö® Fallito! Sei stato scoperto e hai perso *${penalty}* coins come penalit√†.`);
            }
        }

        else if (command === 'cerca') {
            initUser(userId);
            const now = nowSeconds();
            const found = Math.random() < 0.6;
            if (!found) {
                await msg.reply('üîé Hai cercato ma non hai trovato nulla di interessante.');
                return;
            }
            const items = ['moneta d\'argento', 'bottiglia', 'vecchio telefono', 'chiave', 'gemma', 'oggetto raro'];
            const item = items[Math.floor(Math.random() * items.length)];
            const coins = 20 + Math.floor(Math.random() * 181);
            economy[userId].money += coins;
            economy[userId].inventory.push(item);
            saveData();
            await msg.reply(`üîé Hai trovato *${item}* e *${coins}* coins!`);
        }

        // ========== BANCA & TRANSAZIONI ==========
        else if (command === 'deposita' || command === 'deposit') {
            initUser(userId);
            const amount = parseInt(args[0]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Usa: .deposita [amt]');
            if (economy[userId].money < amount) return msg.reply('‚ö†Ô∏è Non hai abbastanza contanti!');
            economy[userId].money -= amount;
            economy[userId].bank += amount;
            saveData();
            await msg.reply(`üè¶ Depositate *${amount}* coins in banca!`);
        }

        else if (command === 'preleva' || command === 'withdraw') {
            initUser(userId);
            const amount = parseInt(args[0]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Usa: .preleva [amt]');
            if (economy[userId].bank < amount) return msg.reply('‚ö†Ô∏è Non hai abbastanza nella banca!');
            economy[userId].bank -= amount;
            economy[userId].money += amount;
            saveData();
            await msg.reply(`üíµ Prelevati *${amount}* coins dalla banca!`);
        }

        else if (command === 'prestito') {
            initUser(userId);
            const amount = parseInt(args[0]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Usa: .prestito [amt]');
            // semplice prestito con interesse fisso 10%
            const interest = Math.ceil(amount * 0.10);
            economy[userId].money += amount;
            economy[userId].debt = (economy[userId].debt || 0) + amount + interest;
            saveData();
            await msg.reply(`üí≥ Prestito concesso: *${amount}* coins. Dovrai ripagare *${amount + interest}* coins (interesse 10%).`);
        }

        else if (command === 'ripaga') {
            initUser(userId);
            const debt = economy[userId].debt || 0;
            if (debt === 0) return msg.reply('‚úÖ Non hai debiti da ripagare!');
            const amount = parseInt(args[0]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Usa: .ripaga [amt]');
            if (economy[userId].money < amount) return msg.reply('‚ö†Ô∏è Non hai abbastanza contanti!');
            economy[userId].money -= amount;
            economy[userId].debt = Math.max(0, debt - amount);
            saveData();
            await msg.reply(`‚úÖ Hai ripagato *${amount}* coins. Debito rimanente: *${economy[userId].debt}* coins.`);
        }

        else if (command === 'investimento' || command === 'invest') {
            initUser(userId);
            const amount = parseInt(args[0]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Usa: .investimento [amt]');
            if (economy[userId].money < amount) return msg.reply('‚ö†Ô∏è Non hai abbastanza contanti!');
            economy[userId].money -= amount;
            // semplice investimento rischio/ricompensa
            const success = Math.random() < 0.6;
            if (success) {
                const profit = Math.ceil(amount * (0.10 + Math.random() * 0.4)); // 10% - 50%
                economy[userId].money += amount + profit;
                saveData();
                await msg.reply(`üìà Investimento riuscito! Guadagni *${profit}* coins (totale restituito *${amount + profit}*).`);
            } else {
                saveData();
                await msg.reply(`üìâ Investimento fallito! Hai perso *${amount}* coins.`);
            }
        }

        // ========== REGALI, SCOMMESSE & MULTIPLICA ==========
        else if (command === 'regalo') {
            initUser(userId);
            const mentioned = await msg.getMentions();
            if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona un utente e specifica un ammontare: .regalo @user [amt]');
            const amount = parseInt(args[1]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Importo non valido!');
            if (economy[userId].money < amount) return msg.reply('‚ö†Ô∏è Non hai abbastanza contanti!');
            const target = mentioned[0];
            initUser(target.id._serialized);
            economy[userId].money -= amount;
            economy[target.id._serialized].money += amount;
            saveData();
            await msg.reply(`üéÅ Hai regalato *${amount}* coins a *${target.pushname || target.number}*!`);
        }

        else if (command === 'scommessa' || command === 'bet') {
            initUser(userId);
            const amount = parseInt(args[0]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Usa: .scommessa [amt]');
            if (economy[userId].money < amount) return msg.reply('‚ö†Ô∏è Non hai abbastanza contanti!');
            const win = Math.random() < 0.48;
            economy[userId].money -= amount;
            if (win) {
                const winnings = amount * (1 + Math.floor(Math.random() * 3)); // raddoppia/triplica...
                economy[userId].money += winnings;
                saveData();
                await msg.reply(`üé∞ Hai vinto! Ricevi *${winnings}* coins!`);
            } else {
                saveData();
                await msg.reply(`üòû Hai perso *${amount}* coins. Ritenta!`);
            }
        }

        else if (command === 'multiplica') {
            initUser(userId);
            const amount = parseInt(args[0]);
            if (isNaN(amount) || amount <= 0) return msg.reply('‚ö†Ô∏è Usa: .multiplica [amt]');
            if (economy[userId].money < amount) return msg.reply('‚ö†Ô∏è Non hai abbastanza contanti!');
            economy[userId].money -= amount;
            const factor = Math.random();
            if (factor < 0.5) {
                saveData();
                return msg.reply('üí• Tentativo fallito! Hai perso il tuo investimento.');
            }
            const gained = Math.floor(amount * (1 + factor * 3)); // possibile grande guadagno
            economy[userId].money += gained;
            saveData();
            await msg.reply(`‚ú® Successo! Il tuo investimento √® diventato *${gained}* coins!`);
        }

        // ========== NEGOZIO ==========
        else if (command === 'shop') {
            const shopItems = [
                { id: 'pacciugo', name: 'Pacciugo', price: 500, desc: 'Aumenta XP' },
                { id: 'scudo', name: 'Scudo', price: 1200, desc: 'Protezione da furti' },
                { id: 'lucky', name: 'Lucky Charm', price: 800, desc: 'Aumenta fortuna' }
            ];
            let text = 'üõí *NEGOZIO*\n\n';
            shopItems.forEach(i => {
                text += `‚Ä¢ ${i.name} - ${i.price} coins ‚Äî ${i.desc}\n`;
            });
            text += '\nUsa: .compra [nome]';
            await msg.reply(text);
        }

        else if (command === 'compra') {
            initUser(userId);
            const itemName = args.join(' ').toLowerCase();
            if (!itemName) return msg.reply('‚ö†Ô∏è Usa: .compra [nome]');
            const catalog = {
                'pacciugo': { price: 500 },
                'scudo': { price: 1200 },
                'lucky charm': { price: 800, key: 'lucky' },
                'lucky': { price: 800 }
            };
            const item = catalog[itemName];
            if (!item) return msg.reply('‚ö†Ô∏è Articolo non trovato!');
            if (economy[userId].money < item.price) return msg.reply('‚ö†Ô∏è Non hai abbastanza contanti!');
            economy[userId].money -= item.price;
            economy[userId].inventory.push(itemName);
            saveData();
            await msg.reply(`‚úÖ Hai comprato *${itemName}* per *${item.price}* coins!`);
        }

        else if (command === 'vendi') {
            initUser(userId);
            const itemName = args.join(' ').toLowerCase();
            if (!itemName) return msg.reply('‚ö†Ô∏è Usa: .vendi [nome]');
            const idx = economy[userId].inventory.indexOf(itemName);
            if (idx === -1) return msg.reply('‚ö†Ô∏è Non possiedi questo oggetto!');
            // prezzo di vendita: 50% del valore base (semplice)
            const basePrices = { 'pacciugo': 500, 'scudo': 1200, 'lucky charm': 800, 'lucky': 800 };
            const price = Math.floor((basePrices[itemName] || 100) * 0.5);
            economy[userId].inventory.splice(idx, 1);
            economy[userId].money += price;
            saveData();
            await msg.reply(`üí∞ Hai venduto *${itemName}* per *${price}* coins.`);
        }

        else if (command === 'usa') {
            initUser(userId);
            const itemName = args.join(' ').toLowerCase();
            if (!itemName) return msg.reply('‚ö†Ô∏è Usa: .usa [nome]');
            const idx = economy[userId].inventory.indexOf(itemName);
            if (idx === -1) return msg.reply('‚ö†Ô∏è Non possiedi questo oggetto!');
            // applica effetto semplice
            economy[userId].inventory.splice(idx, 1);
            if (itemName.includes('pacciugo')) {
                addXP(userId, 50);
                saveData();
                return msg.reply('‚ú® Hai usato Pacciugo! Hai ricevuto +50 XP.');
            } else if (itemName.includes('scudo')) {
                economy[userId].shield = (economy[userId].shield || 0) + 1;
                saveData();
                return msg.reply('üõ°Ô∏è Hai attivato uno Scudo! Protezione extra attiva.');
            } else if (itemName.includes('lucky')) {
                economy[userId].luck = (economy[userId].luck || 0) + 1;
                saveData();
                return msg.reply('üçÄ Lucky Charm attivato! Fortuna aumentata.');
            } else {
                saveData();
                return msg.reply(`‚úÖ Hai usato *${itemName}* (nessun effetto speciale definito).`);
            }
        }

        // ========== CLASSIFICHE ==========
        else if (command === 'top') {
            // mostra i top per saldo totale (semplice: ordina economy)
            const arr = Object.keys(economy).map(k => ({ id: k, total: (economy[k].money || 0) + (economy[k].bank || 0) }));
            arr.sort((a, b) => b.total - a.total);
            const top = arr.slice(0, 10);
            let text = 'üèÜ *TOP RICCHI* (totale coins)\n\n';
            for (let i = 0; i < top.length; i++) {
                text += `${i + 1}. ${top[i].id.split('@')[0]} ‚Äî ${top[i].total}\n`;
            }
            await msg.reply(text);
        }

        // ========== UTILITY & INFO ==========
        else if (command === 'ping') {
            const latency = Date.now() - msg.timestamp * 1000;
            await msg.reply(`üèì Pong!\nLatenza stimata: *${latency}ms*`);
        }

        else if (command === 'uptime') {
            await msg.reply(`‚è∞ Uptime: *${formatTime(Math.floor((Date.now() - startTime) / 1000))}*`);
        }

        else if (command === 'info' || command === 'infobot') {
            const memUsage = process.memoryUsage();
            const text = `ü§ñ *INFO BOT*\n\nVersione: 2.0 Premium\nUptime: ${formatTime(Math.floor((Date.now() - startTime) / 1000))}\nMemoria (rss): ${Math.round(memUsage.rss / 1024 / 1024)} MB\nGruppi attivi: ${Object.keys(groupData).length}\nUtenti registrati: ${Object.keys(userStats).length}`;
            await msg.reply(text);
        }

        else if (command === 'stato') {
            await msg.reply('üü¢ Bot operativo e pronto a rispondere!');
        }

        else if (command === 'qr') {
            // genera qr del testo dato o del numero
            const text = args.join(' ') || 'https://wa.me/';
            try {
                const qrBuffer = await qrcode.toDataURL(text);
                const media = MessageMedia.fromDataURL(qrBuffer);
                await client.sendMessage(msg.from, media, { caption: `üì± QR per: ${text}` });
            } catch (e) {
                await msg.reply('‚ùå Errore nella generazione del QR.');
            }
        }

        // ===== GIOCHI =====
        
        if (command === 'rps') {
            const scelta = args[0]?.toLowerCase();
            const opzioni = ['sasso', 'carta', 'forbici'];
            if (!opzioni.includes(scelta)) return msg.reply('‚ö†Ô∏è Usa: .rps sasso/carta/forbici');
            const botScelta = opzioni[Math.floor(Math.random() * 3)];
            let risultato = '';
            if (scelta === botScelta) risultato = 'ü§ù Pareggio!';
            else if (
                (scelta === 'sasso' && botScelta === 'forbici') ||
                (scelta === 'carta' && botScelta === 'sasso') ||
                (scelta === 'forbici' && botScelta === 'carta')
            ) risultato = 'üéâ Hai vinto!';
            else risultato = 'üò¢ Hai perso!';
            await msg.reply(`üéÆ *MORRA CINESE*\n\nüë§ Tu: ${scelta}\nü§ñ Bot: ${botScelta}\n\n${risultato}`);
        }

        else if (command === 'slot') {
            const simboli = ['üçí', 'üçã', 'üçä', 'üçá', 'üíé', '7Ô∏è‚É£'];
            const r1 = simboli[Math.floor(Math.random() * simboli.length)];
            const r2 = simboli[Math.floor(Math.random() * simboli.length)];
            const r3 = simboli[Math.floor(Math.random() * simboli.length)];
            let result = `üé∞ *SLOT MACHINE*\n\n[ ${r1} | ${r2} | ${r3} ]\n\n`;
            if (r1 === r2 && r2 === r3) result += 'üí∞ JACKPOT! Tre uguali!';
            else if (r1 === r2 || r2 === r3 || r1 === r3) result += '‚ú® Due uguali! Piccola vincita!';
            else result += 'üò¢ Nessuna vincita, riprova!';
            await msg.reply(result);
        }

        else if (command === 'indovina') {
            const chatId = msg.from;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            if (!args[0]) {
                gameStates[chatId].indovina = {
                    numero: Math.floor(Math.random() * 100) + 1,
                    tentativi: 0
                };
                saveData();
                return msg.reply('üé≤ *INDOVINA IL NUMERO*\n\nHo pensato a un numero tra 1 e 100!\nUsa .indovina [numero] per provare!');
            }
            if (!gameStates[chatId].indovina) return msg.reply('‚ö†Ô∏è Nessuna partita attiva! Usa .indovina per iniziare.');
            const num = parseInt(args[0]);
            if (isNaN(num)) return msg.reply('‚ö†Ô∏è Inserisci un numero valido!');
            const game = gameStates[chatId].indovina;
            game.tentativi++;
            if (num === game.numero) {
                await msg.reply(`üéâ *CORRETTO!*\n\nIl numero era ${game.numero}!\nTentativi: ${game.tentativi}`);
                delete gameStates[chatId].indovina;
                saveData();
            } else if (num < game.numero) {
                await msg.reply(`üìà Troppo basso! Tentativo ${game.tentativi}`);
            } else {
                await msg.reply(`üìâ Troppo alto! Tentativo ${game.tentativi}`);
            }
            saveData();
        }

        else if (command === '8ball') {
            if (!args.length) return msg.reply('‚ö†Ô∏è Fai una domanda! Es: .8ball andr√† tutto bene?');
            const risposte = [
                '‚úÖ S√¨, assolutamente', '‚ùå No', 'ü§î Forse', 'üîÆ Molto probabile',
                '‚ö†Ô∏è Non ci contare', '‚ú® Certamente', 'üåü Le stelle dicono di s√¨',
                'üí´ Rifai la domanda pi√π tardi', 'üé± Meglio di no', 'üéØ Senza dubbio',
                'üåÄ Non posso prevederlo ora', 'üí≠ Concentrati e richiedi'
            ];
            await msg.reply(`üé± *PALLA MAGICA*\n\n${risposte[Math.floor(Math.random() * risposte.length)]}`);
        }

        else if (command === 'scelta') {
            const opzioni = msg.body.slice(8).split('|').map(o => o.trim());
            if (opzioni.length < 2) return msg.reply('‚ö†Ô∏è Usa: .scelta opzione1|opzione2|opzione3');
            const scelta = opzioni[Math.floor(Math.random() * opzioni.length)];
            await msg.reply(`üé≤ *SCELTA CASUALE*\n\nHo scelto: *${scelta}*`);
        }

        else if (command === 'dado') {
            const risultato = Math.floor(Math.random() * 6) + 1;
            const dadi = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
            await msg.reply(`üé≤ *DADO*\n\n${dadi[risultato-1]} Hai fatto: *${risultato}*`);
        }

        else if (command === 'moneta') {
            const risultato = Math.random() < 0.5 ? 'Testa' : 'Croce';
            const emoji = risultato === 'Testa' ? 'üëë' : 'ü™ô';
            await msg.reply(`${emoji} *MONETA*\n\nRisultato: *${risultato}*`);
        }

        else if (command === 'blackjack') {
            const chatId = msg.from;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            const deck = [];
            const valori = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
            const semi = ['‚ô†Ô∏è','‚ô•Ô∏è','‚ô£Ô∏è','‚ô¶Ô∏è'];
            valori.forEach(v => semi.forEach(s => deck.push(v+s)));
            const pesca = () => deck.splice(Math.floor(Math.random() * deck.length), 1)[0];
            const calcola = (carte) => {
                let tot = 0, assi = 0;
                carte.forEach(c => {
                    const v = c.slice(0, -2);
                    if (v === 'A') { tot += 11; assi++; }
                    else if (['J','Q','K'].includes(v)) tot += 10;
                    else tot += parseInt(v);
                });
                while (tot > 21 && assi > 0) { tot -= 10; assi--; }
                return tot;
            };
            const player = [pesca(), pesca()];
            const dealer = [pesca()];
            gameStates[chatId].blackjack = { player, dealer, deck, calcola };
            saveData();
            await msg.reply(
                `üÉè *BLACKJACK*\n\n` +
                `üé¥ Le tue carte: ${player.join(' ')} = *${calcola(player)}*\n` +
                `üé¥ Carta dealer: ${dealer[0]}\n\n` +
                `Scrivi *hit* per un'altra carta o *stand* per fermarti`
            );
        }

        else if (text === 'hit' || text === 'stand') {
            const chatId = msg.from;
            if (!gameStates[chatId]?.blackjack) return msg.reply('‚ö†Ô∏è Nessuna partita attiva! Usa .blackjack per iniziare.');
            const game = gameStates[chatId].blackjack;
            if (text === 'hit') {
                const deck = [];
                const valori = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
                const semi = ['‚ô†Ô∏è','‚ô•Ô∏è','‚ô£Ô∏è','‚ô¶Ô∏è'];
                valori.forEach(v => semi.forEach(s => deck.push(v+s)));
                const pesca = () => deck.splice(Math.floor(Math.random() * deck.length), 1)[0];
                game.player.push(pesca());
                const tot = game.calcola(game.player);
                if (tot > 21) {
                    await msg.reply(`üÉè Le tue carte: ${game.player.join(' ')} = *${tot}*\n\nüí• *SBALLATO!* Hai perso!`);
                    delete gameStates[chatId].blackjack;
                } else {
                    await msg.reply(`üÉè Le tue carte: ${game.player.join(' ')} = *${tot}*\n\nScrivi *hit* o *stand*`);
                }
            } else {
                while (game.calcola(game.dealer) < 17) {
                    const deck = [];
                    const valori = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
                    const semi = ['‚ô†Ô∏è','‚ô•Ô∏è','‚ô£Ô∏è','‚ô¶Ô∏è'];
                    valori.forEach(v => semi.forEach(s => deck.push(v+s)));
                    const pesca = () => deck.splice(Math.floor(Math.random() * deck.length), 1)[0];
                    game.dealer.push(pesca());
                }
                const pTot = game.calcola(game.player);
                const dTot = game.calcola(game.dealer);
                let result = `üÉè *RISULTATO*\n\nüë§ Tu: ${game.player.join(' ')} = *${pTot}*\nü§ñ Dealer: ${game.dealer.join(' ')} = *${dTot}*\n\n`;
                if (dTot > 21 || pTot > dTot) result += 'üéâ HAI VINTO!';
                else if (pTot === dTot) result += 'ü§ù PAREGGIO!';
                else result += 'üò¢ HAI PERSO!';
                await msg.reply(result);
                delete gameStates[chatId].blackjack;
            }
            saveData();
        }

        else if (command === 'roulette') {
            if (!args[0]) return msg.reply('‚ö†Ô∏è Usa: .roulette rosso/nero/verde oppure .roulette [numero 0-36]');
            const numero = Math.floor(Math.random() * 37);
            let colore = 'verde';
            if (numero !== 0) {
                const rossi = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
                colore = rossi.includes(numero) ? 'rosso' : 'nero';
            }
            const scommessa = args[0].toLowerCase();
            let vincita = false;
            if (['rosso', 'nero', 'verde'].includes(scommessa)) {
                vincita = scommessa === colore;
            } else if (!isNaN(scommessa)) {
                vincita = parseInt(scommessa) === numero;
            }
            await msg.reply(
                `üé° *ROULETTE*\n\n` +
                `Numero: *${numero}*\n` +
                `Colore: *${colore}*\n\n` +
                `${vincita ? 'üéâ HAI VINTO!' : 'üò¢ HAI PERSO!'}`
            );
        }

        else if (command === 'quiz') {
            const quiz = [
                { q: 'Qual √® la capitale dell\'Italia?', a: ['Roma', 'Milano', 'Napoli'], c: 0 },
                { q: 'Quanti continenti ci sono?', a: ['5', '6', '7'], c: 2 },
                { q: 'Chi ha dipinto la Gioconda?', a: ['Michelangelo', 'Leonardo da Vinci', 'Raffaello'], c: 1 },
                { q: 'Quale pianeta √® pi√π vicino al Sole?', a: ['Venere', 'Marte', 'Mercurio'], c: 2 },
                { q: 'In che anno √® finita la seconda guerra mondiale?', a: ['1943', '1945', '1947'], c: 1 }
            ];
            const q = quiz[Math.floor(Math.random() * quiz.length)];
            const chatId = msg.from;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            gameStates[chatId].quiz = q;
            saveData();
            await msg.reply(
                `‚ùì *QUIZ*\n\n${q.q}\n\n` +
                q.a.map((opt, i) => `${i+1}. ${opt}`).join('\n') +
                `\n\nRispondi con il numero (1, 2 o 3)`
            );
        }

        else if (command === 'trivia') {
            const trivia = [
                'Il miele non scade mai! üçØ',
                'Le banane sono bacche, mentre le fragole no! üçå',
                'Un polpo ha tre cuori! üêô',
                'Le impronte digitali dei koala sono quasi identiche a quelle umane! üê®',
                'Un fulmine √® 5 volte pi√π caldo della superficie del sole! ‚ö°'
            ];
            await msg.reply(`üí° *TRIVIA*\n\n${trivia[Math.floor(Math.random() * trivia.length)]}`);
        }

        else if (command === 'math') {
            const n1 = Math.floor(Math.random() * 20) + 1;
            const n2 = Math.floor(Math.random() * 20) + 1;
            const ops = ['+', '-', '*'];
            const op = ops[Math.floor(Math.random() * ops.length)];
            let result;
            if (op === '+') result = n1 + n2;
            else if (op === '-') result = n1 - n2;
            else result = n1 * n2;
            const chatId = msg.from;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            gameStates[chatId].math = { domanda: `${n1} ${op} ${n2}`, risposta: result };
            saveData();
            await msg.reply(`üßÆ *MATEMATICA VELOCE*\n\nQuanto fa?\n\n*${n1} ${op} ${n2} = ?*\n\nRispondi con il numero!`);
        }

        else if (command === 'memory') {
            const simboli = ['üçé', 'üçå', 'üçí', 'üçá', 'üçä', 'üçã'];
            const sequenza = Array(5).fill(0).map(() => simboli[Math.floor(Math.random() * simboli.length)]);
            const chatId = msg.from;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            gameStates[chatId].memory = { sequenza: sequenza.join(''), attesa: true };
            saveData();
            await msg.reply(`üß† *GIOCO MEMORIA*\n\nMemorizza questa sequenza:\n\n${sequenza.join(' ')}\n\nRiscrivila tra 5 secondi!`);
            setTimeout(() => {
                if (gameStates[chatId]?.memory?.attesa) {
                    gameStates[chatId].memory.attesa = false;
                    saveData();
                }
            }, 5000);
        }

        else if (command === 'tictactoe') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Questo gioco funziona solo nei gruppi!');
            const mentioned = await msg.getMentions();
            if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona un utente per sfidarlo!');
            const chatId = chat.id._serialized;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            gameStates[chatId].tictactoe = {
                board: Array(9).fill('‚¨ú'),
                player1: msg.author || msg.from,
                player2: mentioned[0].id._serialized,
                turn: msg.author || msg.from
            };
            saveData();
            await msg.reply(
                `‚≠ï‚ùå *TRIS*\n\n` +
                `Giocatore 1: @${(msg.author || msg.from).split('@')[0]} (‚≠ï)\n` +
                `Giocatore 2: @${mentioned[0].id._serialized.split('@')[0]} (‚ùå)\n\n` +
                `${gameStates[chatId].tictactoe.board.slice(0,3).join('')}\n` +
                `${gameStates[chatId].tictactoe.board.slice(3,6).join('')}\n` +
                `${gameStates[chatId].tictactoe.board.slice(6,9).join('')}\n\n` +
                `Usa .t [1-9] per giocare!`,
                undefined,
                { mentions: [msg.author || msg.from, mentioned[0].id._serialized] }
            );
        }

        else if (command === 'impiccato') {
            const parole = ['PROGRAMMAZIONE', 'JAVASCRIPT', 'WHATSAPP', 'COMPUTER', 'TELEFONO', 'INTERNET'];
            const parola = parole[Math.floor(Math.random() * parole.length)];
            const chatId = msg.from;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            gameStates[chatId].impiccato = {
                parola,
                scoperte: Array(parola.length).fill('_'),
                errori: 0,
                lettereUsate: []
            };
            saveData();
            await msg.reply(
                `üéØ *IMPICCATO*\n\n` +
                `Parola: ${gameStates[chatId].impiccato.scoperte.join(' ')}\n` +
                `Errori: ${gameStates[chatId].impiccato.errori}/6\n\n` +
                `Indovina una lettera! Usa .l [lettera]`
            );
        }

        else if (command === 'l' && args[0]) {
            const chatId = msg.from;
            if (!gameStates[chatId]?.impiccato) return msg.reply('‚ö†Ô∏è Nessuna partita attiva! Usa .impiccato');
            const game = gameStates[chatId].impiccato;
            const lettera = args[0].toUpperCase();
            if (game.lettereUsate.includes(lettera)) return msg.reply('‚ö†Ô∏è Lettera gi√† usata!');
            game.lettereUsate.push(lettera);
            if (game.parola.includes(lettera)) {
                for (let i = 0; i < game.parola.length; i++) {
                    if (game.parola[i] === lettera) game.scoperte[i] = lettera;
                }
                if (!game.scoperte.includes('_')) {
                    await msg.reply(`üéâ *HAI VINTO!*\n\nLa parola era: *${game.parola}*`);
                    delete gameStates[chatId].impiccato;
                } else {
                    await msg.reply(
                        `‚úÖ Lettera corretta!\n\n` +
                        `Parola: ${game.scoperte.join(' ')}\n` +
                        `Errori: ${game.errori}/6`
                    );
                }
            } else {
                game.errori++;
                if (game.errori >= 6) {
                    await msg.reply(`üíÄ *HAI PERSO!*\n\nLa parola era: *${game.parola}*`);
                    delete gameStates[chatId].impiccato;
                } else {
                    await msg.reply(
                        `‚ùå Lettera sbagliata!\n\n` +
                        `Parola: ${game.scoperte.join(' ')}\n` +
                        `Errori: ${game.errori}/6`
                    );
                }
            }
            saveData();
        }

        else if (command === 'indovinachi') {
            const personaggi = ['Cristiano Ronaldo', 'Einstein', 'Leonardo da Vinci', 'Steve Jobs', 'Michael Jackson'];
            const personaggio = personaggi[Math.floor(Math.random() * personaggi.length)];
            const chatId = msg.from;
            if (!gameStates[chatId]) gameStates[chatId] = {};
            gameStates[chatId].indovinachi = { personaggio, tentativi: 0 };
            saveData();
            await msg.reply(
                `üé≠ *INDOVINA CHI*\n\n` +
                `Ho pensato a un personaggio famoso!\n` +
                `Hai 5 tentativi per indovinare.\n\n` +
                `Usa .chi [nome] per rispondere`
            );
        }

        else if (command === 'chi' && args.length) {
            const chatId = msg.from;
            if (!gameStates[chatId]?.indovinachi) return msg.reply('‚ö†Ô∏è Nessuna partita attiva! Usa .indovinachi');
            const game = gameStates[chatId].indovinachi;
            game.tentativi++;
            const risposta = msg.body.slice(5).trim().toLowerCase();
            if (risposta === game.personaggio.toLowerCase()) {
                await msg.reply(`üéâ *ESATTO!*\n\nIl personaggio era: *${game.personaggio}*\nTentativi: ${game.tentativi}`);
                delete gameStates[chatId].indovinachi;
            } else if (game.tentativi >= 5) {
                await msg.reply(`üò¢ *HAI PERSO!*\n\nIl personaggio era: *${game.personaggio}*`);
                delete gameStates[chatId].indovinachi;
            } else {
                await msg.reply(`‚ùå Sbagliato! Tentativi rimasti: ${5 - game.tentativi}`);
            }
            saveData();
        }

        // ===== FUN & SOCIAL =====

        else if (command === 'meme') {
            await msg.reply('üé≠ *MEME*\n\n"Quando ti dicono che il bot √® pronto"\nüòé Il bot: _ancora in sviluppo_');
        }

        else if (command === 'fact') {
            const facts = [
                'Il cuore di un gamberetto si trova nella testa! ü¶ê',
                'I pinguini hanno le ginocchia! üêß',
                'Una formica pu√≤ sopravvivere 2 settimane sott\'acqua! üêú',
                'Gli elefanti non possono saltare! üêò',
                'Le giraffe possono pulirsi le orecchie con la lingua! ü¶í'
            ];
            await msg.reply(`üìö *FATTO INTERESSANTE*\n\n${facts[Math.floor(Math.random() * facts.length)]}`);
        }

        else if (command === 'quote') {
            const quotes = [
                '"La vita √® quello che accade mentre sei impegnato a fare altri piani" - John Lennon',
                '"Il successo √® la somma di piccoli sforzi ripetuti giorno dopo giorno" - Robert Collier',
                '"Non conta quante volte cadi, ma quante volte ti rialzi" - Vince Lombardi',
                '"Il modo migliore per predire il futuro √® crearlo" - Peter Drucker',
                '"Sii il cambiamento che vuoi vedere nel mondo" - Gandhi'
            ];
            await msg.reply(`üí¨ *CITAZIONE*\n\n${quotes[Math.floor(Math.random() * quotes.length)]}`);
        }

        else if (command === 'joke') {
            const jokes = [
                'Perch√© il libro di matematica √® triste?\nPerch√© ha troppi problemi! üòÑ',
                'Cosa fa un gatto in chiesa?\nMiao! üê±',
                'Qual √® il colmo per un elettricista?\nRimanere folgorato! ‚ö°',
                'Cosa dice un muro a un altro muro?\nCi vediamo all\'angolo! üß±',
                'Perch√© i programmatori confondono Halloween con Natale?\nPerch√© Oct 31 = Dec 25! üéÉüéÑ'
            ];
            await msg.reply(`üòÇ *BARZELLETTA*\n\n${jokes[Math.floor(Math.random() * jokes.length)]}`);
        }

        else if (command === 'consiglio') {
            const consigli = [
                'Bevi pi√π acqua oggi! üíß',
                'Fai una pausa e respira profondamente üßò',
                'Chiama una persona cara che non senti da tempo üìû',
                'Fai una passeggiata all\'aria aperta üö∂',
                'Impara qualcosa di nuovo oggi! üìñ',
                'Sorridi di pi√π, fa bene! üòä'
            ];
            await msg.reply(`üí° *CONSIGLIO DEL GIORNO*\n\n${consigli[Math.floor(Math.random() * consigli.length)]}`);
        }

        else if (command === 'sfida') {
            if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
            const mentioned = await msg.getMentions();
            if (mentioned.length === 0) return msg.reply('‚ö†Ô∏è Menziona qualcuno da sfidare!');
            const sfide = [
                'Chi resiste pi√π a lungo senza guardare il telefono! üì±',
                'Gara di flessioni! üí™',
                'Chi fa la battuta pi√π divertente! üòÇ',
                'Gara di memory! üß†',
                'Chi indovina pi√π capitali! üåç'
            ];
            await msg.reply(
                `‚öîÔ∏è *SFIDA*\n\n` +
                `@${(msg.author || msg.from).split('@')[0]} sfida @${mentioned[0].id._serialized.split('@')[0]}\n\n` +
                `${sfide[Math.floor(Math.random() * sfide.length)]}`,
                undefined,
                { mentions: [msg.author || msg.from, mentioned[0].id._serialized] }
            );
        }

        else if (command === 'complimento') {
            const mentioned = await msg.getMentions();
            const target = mentioned.length > 0 ? `@${mentioned[0].id._serialized.split('@')[0]}` : 'Tu';
            const complimenti = [
                'sei una persona fantastica! ‚≠ê',
                'hai un sorriso contagioso! üòä',
                'sei molto intelligente! üß†',
                'hai un cuore d\'oro! üíõ',
                'sei una fonte di ispirazione! üåü'
            ];
            const mentions = mentioned.length > 0 ? [mentioned[0].id._serialized] : undefined;
            await msg.reply(
                `üíù *COMPLIMENTO*\n\n${target} ${complimenti[Math.floor(Math.random() * complimenti.length)]}`,
                undefined,
                mentions ? { mentions } : undefined
            );
        }

        else if (command === 'insulta') {
            const mentioned = await msg.getMentions();
            const target = mentioned.length > 0 ? `@${mentioned[0].id._serialized.split('@')[0]}` : 'Tu';
            const insulti = [
                'hai lo stesso QI di una pantofola! üëü',
                'sei lento come una lumaca assonnata! üêå',
                'sei confuso come un pinguino nel deserto! üêß',
                'hai la memoria di un pesce rosso! üê†',
                'sei pi√π perso di un turista senza GPS! üó∫Ô∏è'
            ];
            const mentions = mentioned.length > 0 ? [mentioned[0].id._serialized] : undefined;
            await msg.reply(
                `üòà *INSULTO (SCHERZOSO)*\n\n${target} ${insulti[Math.floor(Math.random() * insulti.length)]}`,
                undefined,
                mentions ? { mentions } : undefined
            );
        }

        // ===== COMANDO RIVELA CORRETTO =====
else if (command === 'rivela' || command === 'reveal') {
    try {
        const quotedMsg = await msg.getQuotedMessage();
        
        if (!quotedMsg) {
            return msg.reply(
                '‚ö†Ô∏è *RIVELA IMMAGINE*\n\n' +
                'üìù Rispondi a un\'immagine "visualizzabile una volta" con `.rivela`'
            );
        }
        
        console.log('Tipo messaggio:', quotedMsg.type);
        console.log('Ha media:', quotedMsg.hasMedia);
        
        // Controlla se √® ciphertext (view once criptato) o ha media normale
        const isViewOnce = quotedMsg.type === 'ciphertext';
        const hasNormalMedia = quotedMsg.hasMedia === true;
        
        if (!isViewOnce && !hasNormalMedia) {
            return msg.reply('‚ö†Ô∏è Il messaggio non contiene media!');
        }
        
        if (isViewOnce) {
            return msg.reply(
                '‚ùå *IMPOSSIBILE RIVELARE*\n\n' +
                '‚ö†Ô∏è I messaggi "visualizzabili una volta" sono criptati end-to-end.\n\n' +
                'üîí WhatsApp protegge questi messaggi e non possono essere scaricati dal bot dopo l\'invio.\n\n' +
                'üí° Questo √® per la tua privacy e sicurezza!'
            );
        }
        
        await msg.reply('üîì Download in corso...');
        
        // Scarica il media normale
        const media = await quotedMsg.downloadMedia();
        
        if (!media || !media.data) {
            return msg.reply('‚ùå Impossibile scaricare il media!');
        }
        
        const contact = await msg.getContact();
        const userName = contact.pushname || 'Qualcuno';
        
        // Ricrea il media
        const revealedMedia = new MessageMedia(
            media.mimetype,
            media.data,
            'revealed_' + (media.filename || 'media')
        );
        
        // Invia il media
        await client.sendMessage(
            msg.from, 
            revealedMedia, 
            { caption: `üîì *Media inviato da ${userName}*` }
        );
        
        await msg.reply('‚úÖ Media inviato con successo!');
        
    } catch (err) {
        console.error('Errore rivela:', err);
        await msg.reply('‚ùå Errore: ' + err.message);
    }
}

// ===== COMANDO STICKER CORRETTO =====
else if (command === 's' || command === 'sticker') {
    try {
        let mediaMsg = null;
        
        // 1. Controlla se il messaggio corrente ha media
        if (msg.hasMedia) {
            mediaMsg = msg;
        } 
        // 2. Controlla il messaggio quotato
        else {
            try {
                const quoted = await msg.getQuotedMessage();
                if (quoted) {
                    console.log('Quoted type:', quoted.type);
                    console.log('Quoted hasMedia:', quoted.hasMedia);
                    
                    // Controlla se √® ciphertext (view once)
                    if (quoted.type === 'ciphertext') {
                        return msg.reply(
                            '‚ùå *IMPOSSIBILE CREARE STICKER*\n\n' +
                            '‚ö†Ô∏è Le immagini "visualizzabili una volta" sono criptate.\n\n' +
                            'üîí WhatsApp protegge questi messaggi per la tua privacy.\n\n' +
                            'üí° Invia l\'immagine normalmente per creare lo sticker!'
                        );
                    }
                    
                    // Se ha media normale, procedi
                    if (quoted.hasMedia) {
                        mediaMsg = quoted;
                    }
                }
            } catch (e) {
                console.error('Errore quote:', e);
            }
        }
        
        if (!mediaMsg) {
            return msg.reply(
                "üìé *CREA STICKER*\n\n" +
                "‚úÖ Modi d'uso:\n" +
                "‚Ä¢ Invia immagine con caption `.s`\n" +
                "‚Ä¢ Rispondi a immagine/GIF con `.s`\n\n" +
                "‚ö†Ô∏è Formati: JPG, PNG, GIF, MP4 (max 1MB)\n\n" +
                "‚ùå NON funziona con foto 'view once' (sono criptate)"
            );
        }
        
        // Verifica che sia immagine o video
        const mediaType = mediaMsg.type;
        if (!['image', 'video'].includes(mediaType)) {
            return msg.reply('‚ö†Ô∏è Solo immagini o video/GIF!');
        }
        
        await msg.reply('‚è≥ Creazione sticker...');
        
        // Scarica il media
        const media = await mediaMsg.downloadMedia();
        
        if (!media || !media.data) {
            return msg.reply("‚ùå Impossibile scaricare il media!");
        }
        
        // Verifica il mimetype
        if (!media.mimetype || (!media.mimetype.includes('image') && !media.mimetype.includes('video'))) {
            return msg.reply('‚ö†Ô∏è Formato non supportato!');
        }
        
        const isAnimated = media.mimetype.includes('gif') || media.mimetype.includes('video');
        
        // Crea lo sticker
        const stickerMedia = new MessageMedia(
            media.mimetype,
            media.data,
            'sticker'
        );
        
        const stickerOptions = {
            sendMediaAsSticker: true,
            stickerName: 'WhatsApp Bot',
            stickerAuthor: 'Bot'
        };
        
        if (isAnimated) {
            stickerOptions.stickerAnimated = true;
        }
        
        await client.sendMessage(msg.from, stickerMedia, stickerOptions);
        await msg.reply('‚úÖ Sticker creato! üéâ');
        
    } catch (err) {
        console.error('Errore sticker:', err);
        
        let errorMsg = '‚ùå Errore: ';
        
        if (err.message.includes('large') || err.message.includes('size')) {
            errorMsg += 'File troppo grande! Max 500KB immagini, 1MB GIF.';
        } else if (err.message.includes('format')) {
            errorMsg += 'Formato non supportato.';
        } else if (err.message.includes('Processing')) {
            errorMsg += 'Errore nel processare il media. Riprova con un file pi√π piccolo.';
        } else {
            errorMsg += err.message;
        }
        
        await msg.reply(errorMsg);
    }
}

// COMANDO: .sticker-pack -> info sui limiti degli sticker
else if (command === 'sticker-info' || command === 'stickerinfo') {
    await msg.reply(
        "üé® *INFO STICKER*\n\n" +
        "üìè *Limiti:*\n" +
        "‚Ä¢ Immagini: max 500KB\n" +
        "‚Ä¢ GIF/Video: max 1MB\n" +
        "‚Ä¢ Durata video: max 6 secondi\n" +
        "‚Ä¢ Risoluzione: 512x512 px (ottimale)\n\n" +
        "‚úÖ *Formati supportati:*\n" +
        "‚Ä¢ JPG, PNG (statici)\n" +
        "‚Ä¢ GIF (animati)\n" +
        "‚Ä¢ MP4 (animati, max 6s)\n\n" +
        "üí° *Uso:*\n" +
        "‚Ä¢ `.s` su immagine\n" +
        "‚Ä¢ `.s` rispondendo a media"
    );
}

        // BONUS: Roulette dell'amore - trova partner per l'utente che scrive
else if (command === 'amore' || command === 'trovamore') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Questo comando funziona solo nei gruppi!');
    
    try {
        const senderId = msg.author || msg.from;
        
        // Ottieni tutti i partecipanti (escluso chi ha mandato il comando e il bot)
        const botId = client.info?.wid?._serialized || client.info?.me?._serialized || '';
        const participants = chat.participants.filter(p => {
            return p.id._serialized !== senderId && p.id._serialized !== botId;
        });
        
        if (participants.length === 0) {
            return msg.reply('‚ö†Ô∏è Non ci sono altri membri disponibili nel gruppo!');
        }
        
        // Scegli un partner casuale
        const partner = participants[Math.floor(Math.random() * participants.length)];
        const percentuale = Math.floor(Math.random() * 101);
        
        let messaggio = '';
        if (percentuale < 30) messaggio = 'üíî Non sembra promettente...';
        else if (percentuale < 60) messaggio = 'üíõ C\'√® del potenziale!';
        else if (percentuale < 80) messaggio = 'üíï Bella coppia!';
        else messaggio = 'üíñ Match perfetto!';
        
        const nomePartner = partner.id._serialized.split('@')[0];
        const nomeSender = senderId.split('@')[0];
        
        await msg.reply(
            `üíò *ROULETTE DELL\'AMORE* üé∞\n\n` +
            `@${nomeSender} ‚ù§Ô∏è @${nomePartner}\n\n` +
            `Compatibilit√†: *${percentuale}%*\n${messaggio}`,
            undefined,
            { mentions: [senderId, partner.id._serialized] }
        );
        
    } catch (err) {
        console.error('Errore amoroulette:', err);
        await msg.reply('‚ùå Errore nella ricerca del partner. Riprova!');
    }
}

        // VARIANTE: Crea coppia con utenti specifici
else if (command === 'shippa') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Questo comando funziona solo nei gruppi!');
    
    const mentioned = await msg.getMentions();
    
    if (mentioned.length === 0) {
        // Se non ci sono mention, comportati come creacoppia
        return msg.reply('üí° Usa `.creacoppia` per una coppia casuale, oppure `.shippa @user1 @user2` per shippare due persone specifiche!');
    }
    
    if (mentioned.length === 1) {
        return msg.reply('‚ö†Ô∏è Menziona un secondo utente da shippare!');
    }
    
    if (mentioned.length >= 2) {
        const frasi = [
            'sono ufficialmente una coppia! üíë',
            'si sono sposati! üíí',
            'sono innamorati! üòç',
            'sono fidanzati! üíï',
            'sono destinati a stare insieme! ‚ú®',
            'hanno fatto match! üíñ',
            'sono anime gemelle! üí´'
        ];
        
        const fraseScelta = frasi[Math.floor(Math.random() * frasi.length)];
        const nome1 = mentioned[0].id._serialized.split('@')[0];
        const nome2 = mentioned[1].id._serialized.split('@')[0];
        
        await msg.reply(
            `üíò *CUPIDO HA COLPITO!* üèπ\n\n` +
            `@${nome1} e @${nome2} ${fraseScelta}\n\n` +
            `üíï Che coppia! üéâ`,
            undefined,
            { mentions: [mentioned[0].id._serialized, mentioned[1].id._serialized] }
        );
    }
}

        else if (command === 'creacoppia') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Questo comando funziona solo nei gruppi!');
    
    try {
        // Ottieni tutti i partecipanti del gruppo (escluso il bot)
        const participants = chat.participants.filter(p => {
            // Escludi il bot stesso
            const botId = client.info?.wid?._serialized || client.info?.me?._serialized || '';
            return p.id._serialized !== botId;
        });
        
        if (participants.length < 2) {
            return msg.reply('‚ö†Ô∏è Servono almeno 2 membri nel gruppo (escluso il bot)!');
        }
        
        // Scegli due utenti casuali diversi
        const shuffled = participants.sort(() => Math.random() - 0.5);
        const user1 = shuffled[0];
        const user2 = shuffled[1];
        
        // Frasi romantiche
        const frasi = [
            'sono ufficialmente una coppia! üíë',
            'si sono sposati! üíí',
            'sono innamorati! üòç',
            'sono fidanzati! üíï',
            'sono destinati a stare insieme! ‚ú®',
            'hanno fatto match! üíñ',
            'sono anime gemelle! üí´',
            'formano una coppia perfetta! üíù',
            'si sono dichiarati! üíå',
            'hanno iniziato a frequentarsi! ü•∞'
        ];
        
        const fraseScelta = frasi[Math.floor(Math.random() * frasi.length)];
        
        // Ottieni i nomi o numeri degli utenti
        const nome1 = user1.id.user || user1.id._serialized.split('@')[0];
        const nome2 = user2.id.user || user2.id._serialized.split('@')[0];
        
        await msg.reply(
            `üíò *CUPIDO HA COLPITO!* üèπ\n\n` +
            `@${nome1} e @${nome2} ${fraseScelta}\n\n` +
            `üíï Auguri ai neo-fidanzati! üéâ`,
            undefined,
            { mentions: [user1.id._serialized, user2.id._serialized] }
        );
        
    } catch (err) {
        console.error('Errore creacoppia:', err);
        await msg.reply('‚ùå Errore nella creazione della coppia. Riprova!');
    }
}

        // ===== TEXT MANIPULATION =====

        else if (command === 'faketext') {
            if (!args.length) return msg.reply('‚ö†Ô∏è Usa: .faketext [testo]');
            const testo = msg.body.slice(10);
            await msg.reply(`‚ú® *TESTO FAKE*\n\n_"${testo}"_\n\n- Qualcuno, probabilmente`);
        }

        else if (command === 'ascii') {
            if (!args.length) return msg.reply('‚ö†Ô∏è Usa: .ascii [testo]');
            const testo = args.join(' ').toUpperCase();
            const ascii = {
                'A': '  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó \n ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó\n ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë\n ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë\n ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë',
                'B': ' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó \n ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó\n ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù\n ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó\n ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù',
                'C': '  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó\n ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù\n ‚ñà‚ñà‚ïë     \n ‚ñà‚ñà‚ïë     \n ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó'
            };
            const output = testo.split('').map(c => ascii[c] || c).join('\n\n');
            await msg.reply(`\`\`\`\n${output}\n\`\`\``);
        }

        else if (command === 't' && args[0]) {
    const chatId = chat.id._serialized;
    if (!gameStates[chatId]?.tictactoe) return msg.reply('‚ö†Ô∏è Nessuna partita attiva! Usa .tictactoe');
    
    const game = gameStates[chatId].tictactoe;
    const pos = parseInt(args[0]) - 1;
    
    if (isNaN(pos) || pos < 0 || pos > 8) return msg.reply('‚ö†Ô∏è Posizione non valida! Usa 1-9');
    if (game.board[pos] !== '‚¨ú') return msg.reply('‚ö†Ô∏è Posizione gi√† occupata!');
    
    const currentPlayer = msg.author || msg.from;
    if (currentPlayer !== game.turn) return msg.reply('‚ö†Ô∏è Non √® il tuo turno!');
    
    const symbol = currentPlayer === game.player1 ? '‚≠ï' : '‚ùå';
    game.board[pos] = symbol;
    
    // Controlla vittoria
    const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    const hasWon = wins.some(w => w.every(i => game.board[i] === symbol));
    
    if (hasWon) {
        await msg.reply(
            `üéâ *VITTORIA!*\n\n` +
            `${game.board.slice(0,3).join('')}\n` +
            `${game.board.slice(3,6).join('')}\n` +
            `${game.board.slice(6,9).join('')}\n\n` +
            `@${currentPlayer.split('@')[0]} ha vinto!`,
            undefined,
            { mentions: [currentPlayer] }
        );
        delete gameStates[chatId].tictactoe;
    } else if (!game.board.includes('‚¨ú')) {
        await msg.reply(
            `ü§ù *PAREGGIO!*\n\n` +
            `${game.board.slice(0,3).join('')}\n` +
            `${game.board.slice(3,6).join('')}\n` +
            `${game.board.slice(6,9).join('')}`
        );
        delete gameStates[chatId].tictactoe;
    } else {
        game.turn = game.turn === game.player1 ? game.player2 : game.player1;
        await msg.reply(
            `${game.board.slice(0,3).join('')}\n` +
            `${game.board.slice(3,6).join('')}\n` +
            `${game.board.slice(6,9).join('')}\n\n` +
            `Turno di @${game.turn.split('@')[0]}`,
            undefined,
            { mentions: [game.turn] }
        );
    }
    saveData();
}

        else if (command === 'reverse') {
            if (!args.length) return msg.reply('‚ö†Ô∏è Usa: .reverse [testo]');
            const testo = msg.body.slice(9);
            await msg.reply(`üîÑ *TESTO INVERTITO*\n\n${testo.split('').reverse().join('')}`);
        }

        else if (command === 'caps') {
            if (!args.length) return msg.reply('‚ö†Ô∏è Usa: .caps [testo]');
            const testo = msg.body.slice(6);
            await msg.reply(testo.toUpperCase());
        }

        else if (command === 'mock') {
            if (!args.length) return msg.reply('‚ö†Ô∏è Usa: .mock [testo]');
            const testo = msg.body.slice(6);
            const mocked = testo.split('').map((c, i) => i % 2 === 0 ? c.toLowerCase() : c.toUpperCase()).join('');
            await msg.reply(`ü§™ ${mocked}`);
        }

        // ===== MODERAZIONE =====

else if (command === 'purge') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    const num = parseInt(args[0]);
    if (isNaN(num) || num < 1 || num > 100) {
        return msg.reply('‚ö†Ô∏è Specifica un numero tra 1 e 100!\n\nüìù Esempio: `.purge 10`');
    }
    
    try {
        await msg.reply(`üóëÔ∏è Eliminazione di ${num} messaggi in corso...\n\n_Nota: WhatsApp Web ha limitazioni sulla cancellazione massiva_`);
        
        // Ottieni i messaggi della chat
        const messages = await chat.fetchMessages({ limit: num + 1 }); // +1 per escludere il comando stesso
        let deleted = 0;
        
        for (let i = 1; i < messages.length && i <= num; i++) {
            try {
                await messages[i].delete(true); // true = elimina per tutti
                deleted++;
                await new Promise(resolve => setTimeout(resolve, 300)); // Pausa per evitare rate limit
            } catch (e) {
                console.error('Errore eliminazione messaggio:', e);
            }
        }
        
        await msg.reply(`‚úÖ Eliminati ${deleted} messaggi su ${num} richiesti.`);
    } catch (err) {
        console.error('Errore purge:', err);
        await msg.reply('‚ùå Errore durante l\'eliminazione dei messaggi.');
    }
}

// ===== COMANDO PIN CORRETTO =====
else if (command === 'pin') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    try {
        let messageToPin = null;
        
        // Prova a ottenere il messaggio quotato
        try {
            const quotedMsg = await msg.getQuotedMessage();
            if (quotedMsg) {
                messageToPin = quotedMsg;
            }
        } catch (e) {
            console.log('Nessun messaggio quotato');
        }
        
        if (!messageToPin) {
            return msg.reply('‚ö†Ô∏è Rispondi a un messaggio per fissarlo!');
        }
        
        // Verifica che il bot sia admin
        if (!await isBotAdmin(chat)) {
            return msg.reply('‚ùå Il bot deve essere admin per fissare messaggi!');
        }
        
        // Usa il metodo corretto per pinnare
        await chat.sendStateRecording(); // Segnala che il bot sta facendo qualcosa
        await client.pupPage.evaluate((chatId, msgId) => {
            return window.Store.pinUnpinMsg(
                window.Store.Msg.get(msgId),
                true // true = pin, false = unpin
            );
        }, chat.id._serialized, messageToPin.id._serialized);
        
        await msg.reply('üìå Messaggio fissato con successo!');
    } catch (err) {
        console.error('Errore pin:', err);
        await msg.reply('‚ùå Errore nel fissare il messaggio: ' + err.message);
    }
}

// ===== COMANDO UNPIN CORRETTO =====
else if (command === 'unpin') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    try {
        let messageToUnpin = null;
        
        try {
            const quotedMsg = await msg.getQuotedMessage();
            if (quotedMsg) {
                messageToUnpin = quotedMsg;
            }
        } catch (e) {
            console.log('Nessun messaggio quotato');
        }
        
        if (!messageToUnpin) {
            return msg.reply('‚ö†Ô∏è Rispondi a un messaggio fissato per rimuoverlo!');
        }
        
        if (!await isBotAdmin(chat)) {
            return msg.reply('‚ùå Il bot deve essere admin per rimuovere messaggi fissati!');
        }
        
        await client.pupPage.evaluate((chatId, msgId) => {
            return window.Store.pinUnpinMsg(
                window.Store.Msg.get(msgId),
                false // false = unpin
            );
        }, chat.id._serialized, messageToUnpin.id._serialized);
        
        await msg.reply('üìå Messaggio rimosso dai fissati!');
    } catch (err) {
        console.error('Errore unpin:', err);
        await msg.reply('‚ùå Errore nel rimuovere il pin: ' + err.message);
    }
}

// ===== GESTIONE RICHIESTE GRUPPO =====

else if (command === 'accettarichieste') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    try {
        autoAcceptRequests[chat.id._serialized] = true;
        await msg.reply('‚úÖ *Accettazione automatica attivata!*\n\nIl bot accetter√† automaticamente tutte le richieste di ingresso nel gruppo.');
    } catch (err) {
        await msg.reply('‚ùå Errore nell\'attivare l\'accettazione automatica.');
    }
}

else if (command === 'rifiutarichieste') {
    if (!isGroup) return msg.reply('‚ö†Ô∏è Comando disponibile solo nei gruppi!');
    if (!await isAdmin(msg, chat)) return msg.reply('‚ö†Ô∏è Solo gli admin possono usare questo comando!');
    
    try {
        autoAcceptRequests[chat.id._serialized] = false;
        await msg.reply('‚ùå *Accettazione automatica disattivata!*\n\nIl bot non accetter√† pi√π automaticamente le richieste di ingresso.');
    } catch (err) {
        await msg.reply('‚ùå Errore nel disattivare l\'accettazione automatica.');
    }
}

// ===== COMANDO LEVEL =====
if (command === 'level' || command === 'livello') {
    const userId = getUserIdFromMsg(msg);
    const stats = getUserStats(userId);
    const level = stats.level || 1;
    const xp = stats.xp || 0;
    const xpForNext = level * 100;
    const progressBar = createProgressBar(xp, xpForNext);
    
    try {
        const contact = await msg.getContact();
        const userName = contact.pushname || contact.name || 'Utente';
        
        await msg.reply(
            `üèÜ *LIVELLO DI ${userName.toUpperCase()}*\n\n` +
            `üìä Livello: *${level}*\n` +
            `‚≠ê XP: *${xp}* / ${xpForNext}\n` +
            `${progressBar}\n\n` +
            `üìà Progresso: ${Math.floor((xp / xpForNext) * 100)}%\n` +
            `üéØ XP mancanti: *${xpForNext - xp}*\n\n` +
            `üí¨ Messaggi inviati: ${stats.messages || 0}`
        );
    } catch (err) {
        console.error('Errore level:', err);
        await msg.reply('‚ùå Errore nel recuperare il livello.');
    }
}

// ===== COMANDO PROFILO =====
else if (command === 'profilo' || command === 'profile') {
    const userId = getUserIdFromMsg(msg);
    const stats = getUserStats(userId);
    const level = stats.level || 1;
    const xp = stats.xp || 0;
    const messages = stats.messages || 0;
    const rep = stats.reputation || 0;
    const bio = stats.bio || 'Nessuna bio impostata';
    
    try {
        const contact = await msg.getContact();
        const userName = contact.pushname || contact.name || 'Utente';
        const about = contact.statusMessage || 'Nessuno stato';
        
        // Determina il rank
        let rank = 'ü•â Bronzo';
        if (level >= 30) rank = 'üíé Diamante';
        else if (level >= 20) rank = 'üèÖ Platino';
        else if (level >= 10) rank = 'ü•á Oro';
        else if (level >= 5) rank = 'ü•à Argento';
        
        // Recupera economia
        const eco = economy[userId] || { money: 0, bank: 0 };
        
        // Recupera warnings
        const warns = warnings[userId] || 0;
        
        const profileMsg = 
            `üë§ *PROFILO DI ${userName.toUpperCase()}*\n\n` +
            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
            `üèÜ Livello: *${level}*\n` +
            `‚≠ê XP Totale: *${xp}*\n` +
            `üéñÔ∏è Rank: ${rank}\n\n` +
            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
            `üìä *STATISTICHE*\n` +
            `üí¨ Messaggi: ${messages}\n` +
            `‚≠ê Reputazione: ${rep}\n` +
            `üí∞ Money: $${eco.money}\n` +
            `üè¶ Bank: $${eco.bank}\n` +
            `‚ö†Ô∏è Warning: ${warns}/3\n\n` +
            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
            `üí≠ Bio: _"${bio}"_\n` +
            `üì± Stato: _"${about}"_\n` +
            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
        
        // Prova a inviare con foto profilo
        try {
            const profilePic = await contact.getProfilePicUrl();
            const media = await MessageMedia.fromUrl(profilePic);
            await client.sendMessage(msg.from, media, { caption: profileMsg });
        } catch (e) {
            // Se non c'√® foto profilo, invia solo testo
            await msg.reply(profileMsg);
        }
        
    } catch (err) {
        console.error('Errore profilo:', err);
        await msg.reply('‚ùå Errore nel recuperare il profilo.');
    }
}



        // Risposta quiz/math se l'utente risponde con numeri
        else if (!isNaN(text) && text.trim() !== '') {
            const chatId = msg.from;
            const num = parseInt(text);
            
            // Controlla quiz
            if (gameStates[chatId]?.quiz) {
                const q = gameStates[chatId].quiz;
                if (num >= 1 && num <= 3) {
                    if (num - 1 === q.c) {
                        await msg.reply(`üéâ *CORRETTO!*\n\nLa risposta giusta era: ${q.a[q.c]}`);
                    } else {
                        await msg.reply(`‚ùå *SBAGLIATO!*\n\nLa risposta corretta era: ${q.a[q.c]}`);
                    }
                    delete gameStates[chatId].quiz;
                    saveData();
                }
            }
            
            // Controlla math
            if (gameStates[chatId]?.math) {
                const m = gameStates[chatId].math;
                if (num === m.risposta) {
                    await msg.reply(`üéâ *CORRETTO!*\n\n${m.domanda} = ${m.risposta}`);
                } else {
                    await msg.reply(`‚ùå *SBAGLIATO!*\n\n${m.domanda} = ${m.risposta}`);
                }
                delete gameStates[chatId].math;
                saveData();
            }
        }
        
        // Risposta memory
        else if (gameStates[msg.from]?.memory && !gameStates[msg.from].memory.attesa) {
            const game = gameStates[msg.from].memory;
            if (text === game.sequenza.toLowerCase()) {
                await msg.reply(`üéâ *ESATTO!*\n\nHai memorizzato la sequenza corretta!`);
            } else {
                await msg.reply(`‚ùå *SBAGLIATO!*\n\nLa sequenza era: ${game.sequenza}`);
            }
            delete gameStates[msg.from].memory;
            saveData();
        }

    

        // ========== Fallback per comandi non riconosciuti ==========
        else {
            // lasciare silenzioso o suggerire .menu
            // per non sovraccaricare il gruppo rispondi solo se in privato
            if (!isGroup) await msg.reply('‚ùì Comando non riconosciuto. Usa .menu per la lista dei comandi.');
        }

     } catch (err) {
        console.error('‚ö†Ô∏è Errore nel processamento del messaggio:', err);
    }
}); // Chiude client.on('message')     
       

    


// salva dati al termine del processo
process.on('exit', () => saveData());
process.on('SIGINT', () => { saveData(); process.exit(); });
process.on('SIGTERM', () => { saveData(); process.exit(); });

// avvia il client
client.initialize();

